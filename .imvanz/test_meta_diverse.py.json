[
  {
    "timestamp": "2025-11-21T23:05:27.821Z",
    "fileName": "test_meta_diverse.py",
    "content": "\"\"\"\r\nDiverse Meta-Controller Test\r\nآزمایش متنوع برای نمایش انتخاب روش‌های مختلف\r\n\"\"\"\r\n\r\nimport io\r\nimport sys\r\nimport os\r\n\r\nsys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')\r\nsys.path.append(os.path.dirname(os.path.dirname(__file__)))\r\n\r\nfrom cad3d.super_ai.unified_ai_system import (\r\n    UnifiedAISystem,\r\n    AITaskType\r\n)\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  DIVERSE META-CONTROLLER TEST - Different Methods Selection\")\r\nprint(\"=\"*80 + \"\\n\")\r\n\r\nunified = UnifiedAISystem()\r\nprint(\"✓ System initialized with Meta-Controller\\n\")\r\n\r\n# Test cases designed to trigger different methods\r\ntest_cases = [\r\n    {\r\n        \"query\": \"hi\",\r\n        \"expected\": \"Prompt Engineering\",\r\n        \"reason\": \"Very simple, very fast needed\"\r\n    },\r\n    {\r\n        \"query\": \"تحلیل جامع و کامل سیستم سازه‌ای ساختمان 20 طبقه با بررسی کامل استانداردهای ملی و بین‌المللی و ارائه راهکارهای بهینه‌سازی\",\r\n        \"task\": AITaskType.STRUCTURAL_CALCULATION,\r\n        \"expected\": \"Fine-Tuning\",\r\n        \"reason\": \"Very complex, specialized, high accuracy needed\"\r\n    },\r\n    {\r\n        \"query\": \"طراحی سیستم تهویه مطبوع\",\r\n        \"task\": AITaskType.MEP_OPTIMIZATION,\r\n        \"expected\": \"LoRA or PEFT\",\r\n        \"reason\": \"MEP domain, specialized\"\r\n    },\r\n    {\r\n        \"query\": \"what is the formula for area\",\r\n        \"expected\": \"RAG\",\r\n        \"reason\": \"Knowledge query, fast\"\r\n    },\r\n    {\r\n        \"query\": \"use lora adapter for structural beam analysis\",\r\n        \"expected\": \"LoRA\",\r\n        \"reason\": \"Explicit LoRA keyword\"\r\n    },\r\n    {\r\n        \"query\": \"apply peft for mep\",\r\n        \"expected\": \"PEFT\",\r\n        \"reason\": \"Explicit PEFT keyword\"\r\n    },\r\n    {\r\n        \"query\": \"use fine-tuning model\",\r\n        \"expected\": \"Fine-Tuning\",\r\n        \"reason\": \"Explicit fine-tuning keyword\"\r\n    },\r\n]\r\n\r\nresults = []\r\n\r\nfor i, test in enumerate(test_cases, 1):\r\n    print(f\"\\n{'='*80}\")\r\n    print(f\"  TEST {i}: {test['reason']}\")\r\n    print(f\"{'='*80}\")\r\n    \r\n    query = test[\"query\"]\r\n    task = test.get(\"task\")\r\n    expected = test[\"expected\"]\r\n    \r\n    print(f\"\\nQuery: {query}\")\r\n    print(f\"Expected: {expected}\")\r\n    \r\n    # Get explanation\r\n    explanation = unified.explain_selection(query, task)\r\n    selected = explanation[\"selected_method\"]\r\n    \r\n    print(f\"\\nSelected: {selected}\")\r\n    print(f\"Reasoning: {explanation['reasoning']}\")\r\n    print(f\"Domain: {explanation['features']['domain']}\")\r\n    print(f\"Complexity: {explanation['features']['complexity']}\")\r\n    \r\n    # Execute\r\n    response = unified.query(query, task_type=task)\r\n    actual = response[\"method\"]\r\n    \r\n    match = \"✓\" if selected.lower() in expected.lower() or expected.lower() in selected.lower() else \"✗\"\r\n    print(f\"\\nMatch: {match} (Expected: {expected}, Got: {actual})\")\r\n    \r\n    results.append({\r\n        \"test\": i,\r\n        \"expected\": expected,\r\n        \"selected\": selected,\r\n        \"actual\": actual,\r\n        \"match\": match == \"✓\"\r\n    })\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  RESULTS SUMMARY\")\r\nprint(\"=\"*80)\r\n\r\n# Count by method\r\nstatus = unified.get_system_status()\r\nstats = status[\"usage_statistics\"]\r\n\r\nprint(f\"\\nTotal Queries: {stats['total_queries']}\")\r\nprint(f\"  RAG: {stats['rag_calls']}\")\r\nprint(f\"  Fine-Tuning: {stats['fine_tuning_calls']}\")\r\nprint(f\"  LoRA: {stats['lora_calls']}\")\r\nprint(f\"  Prompt Engineering: {stats['prompt_calls']}\")\r\nprint(f\"  PEFT: {stats['peft_calls']}\")\r\n\r\nprint(\"\\nMethod Diversity:\")\r\nmethods_used = []\r\nfor key, val in stats.items():\r\n    if key.endswith('_calls') and val > 0:\r\n        method = key.replace('_calls', '').replace('_', ' ').title()\r\n        methods_used.append(method)\r\n\r\nprint(f\"  {len(methods_used)} different methods used: {', '.join(methods_used)}\")\r\n\r\nmatches = sum(1 for r in results if r[\"match\"])\r\nprint(f\"\\nAccuracy: {matches}/{len(results)} ({100*matches//len(results)}%)\")\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  META-CONTROLLER INTELLIGENCE DEMONSTRATED!\")\r\nprint(\"=\"*80)\r\nprint(\"\\nKey Features:\")\r\nprint(\"  ✓ Analyzes query complexity (SIMPLE → VERY_COMPLEX)\")\r\nprint(\"  ✓ Detects domain (architecture, structural, MEP, calculation)\")\r\nprint(\"  ✓ Assesses urgency (REALTIME → BATCH)\")\r\nprint(\"  ✓ Calculates confidence requirements (70% - 100%)\")\r\nprint(\"  ✓ Multi-criteria scoring: speed (30%) + accuracy (40%) + cost (30%)\")\r\nprint(\"  ✓ Adaptive learning from execution history\")\r\nprint(\"  ✓ Transparent decision explanation\")\r\nprint(\"  ✓ Selects optimal method based on query characteristics\")\r\nprint(\"\\n\" + \"=\"*80 + \"\\n\")\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:05:30.359Z",
    "fileName": "test_meta_diverse.py",
    "content": "\"\"\"\r\nDiverse Meta-Controller Test\r\nآزمایش متنوع برای نمایش انتخاب روش‌های مختلف\r\n\"\"\"\r\n\r\nimport io\r\nimport sys\r\nimport os\r\n\r\nsys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')\r\nsys.path.append(os.path.dirname(os.path.dirname(__file__)))\r\n\r\nfrom cad3d.super_ai.unified_ai_system import (\r\n    UnifiedAISystem,\r\n    AITaskType\r\n)\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  DIVERSE META-CONTROLLER TEST - Different Methods Selection\")\r\nprint(\"=\"*80 + \"\\n\")\r\n\r\nunified = UnifiedAISystem()\r\nprint(\"✓ System initialized with Meta-Controller\\n\")\r\n\r\n# Test cases designed to trigger different methods\r\ntest_cases = [\r\n    {\r\n        \"query\": \"hi\",\r\n        \"expected\": \"Prompt Engineering\",\r\n        \"reason\": \"Very simple, very fast needed\"\r\n    },\r\n    {\r\n        \"query\": \"تحلیل جامع و کامل سیستم سازه‌ای ساختمان 20 طبقه با بررسی کامل استانداردهای ملی و بین‌المللی و ارائه راهکارهای بهینه‌سازی\",\r\n        \"task\": AITaskType.STRUCTURAL_CALCULATION,\r\n        \"expected\": \"Fine-Tuning\",\r\n        \"reason\": \"Very complex, specialized, high accuracy needed\"\r\n    },\r\n    {\r\n        \"query\": \"طراحی سیستم تهویه مطبوع\",\r\n        \"task\": AITaskType.MEP_OPTIMIZATION,\r\n        \"expected\": \"LoRA or PEFT\",\r\n        \"reason\": \"MEP domain, specialized\"\r\n    },\r\n    {\r\n        \"query\": \"what is the formula for area\",\r\n        \"expected\": \"RAG\",\r\n        \"reason\": \"Knowledge query, fast\"\r\n    },\r\n    {\r\n        \"query\": \"use lora adapter for structural beam analysis\",\r\n        \"expected\": \"LoRA\",\r\n        \"reason\": \"Explicit LoRA keyword\"\r\n    },\r\n    {\r\n        \"query\": \"apply peft for mep\",\r\n        \"expected\": \"PEFT\",\r\n        \"reason\": \"Explicit PEFT keyword\"\r\n    },\r\n    {\r\n        \"query\": \"use fine-tuning model\",\r\n        \"expected\": \"Fine-Tuning\",\r\n        \"reason\": \"Explicit fine-tuning keyword\"\r\n    },\r\n]\r\n\r\nresults = []\r\n\r\nfor i, test in enumerate(test_cases, 1):\r\n    print(f\"\\n{'='*80}\")\r\n    print(f\"  TEST {i}: {test['reason']}\")\r\n    print(f\"{'='*80}\")\r\n    \r\n    query = test[\"query\"]\r\n    task = test.get(\"task\")\r\n    expected = test[\"expected\"]\r\n    \r\n    print(f\"\\nQuery: {query}\")\r\n    print(f\"Expected: {expected}\")\r\n    \r\n    # Get explanation\r\n    explanation = unified.explain_selection(query, task)\r\n    selected = explanation[\"selected_method\"]\r\n    \r\n    print(f\"\\nSelected: {selected}\")\r\n    print(f\"Reasoning: {explanation['reasoning']}\")\r\n    print(f\"Domain: {explanation['features']['domain']}\")\r\n    print(f\"Complexity: {explanation['features']['complexity']}\")\r\n    \r\n    # Execute\r\n    response = unified.query(query, task_type=task)\r\n    actual = response[\"method\"]\r\n    \r\n    match = \"✓\" if selected.lower() in expected.lower() or expected.lower() in selected.lower() else \"✗\"\r\n    print(f\"\\nMatch: {match} (Expected: {expected}, Got: {actual})\")\r\n    \r\n    results.append({\r\n        \"test\": i,\r\n        \"expected\": expected,\r\n        \"selected\": selected,\r\n        \"actual\": actual,\r\n        \"match\": match == \"✓\"\r\n    })\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  RESULTS SUMMARY\")\r\nprint(\"=\"*80)\r\n\r\n# Count by method\r\nstatus = unified.get_system_status()\r\nstats = status[\"usage_statistics\"]\r\n\r\nprint(f\"\\nTotal Queries: {stats['total_queries']}\")\r\nprint(f\"  RAG: {stats['rag_calls']}\")\r\nprint(f\"  Fine-Tuning: {stats['fine_tuning_calls']}\")\r\nprint(f\"  LoRA: {stats['lora_calls']}\")\r\nprint(f\"  Prompt Engineering: {stats['prompt_calls']}\")\r\nprint(f\"  PEFT: {stats['peft_calls']}\")\r\n\r\nprint(\"\\nMethod Diversity:\")\r\nmethods_used = []\r\nfor key, val in stats.items():\r\n    if key.endswith('_calls') and val > 0:\r\n        method = key.replace('_calls', '').replace('_', ' ').title()\r\n        methods_used.append(method)\r\n\r\nprint(f\"  {len(methods_used)} different methods used: {', '.join(methods_used)}\")\r\n\r\nmatches = sum(1 for r in results if r[\"match\"])\r\nprint(f\"\\nAccuracy: {matches}/{len(results)} ({100*matches//len(results)}%)\")\r\n\r\nprint(\"\\n\" + \"=\"*80)\r\nprint(\"  META-CONTROLLER INTELLIGENCE DEMONSTRATED!\")\r\nprint(\"=\"*80)\r\nprint(\"\\nKey Features:\")\r\nprint(\"  ✓ Analyzes query complexity (SIMPLE → VERY_COMPLEX)\")\r\nprint(\"  ✓ Detects domain (architecture, structural, MEP, calculation)\")\r\nprint(\"  ✓ Assesses urgency (REALTIME → BATCH)\")\r\nprint(\"  ✓ Calculates confidence requirements (70% - 100%)\")\r\nprint(\"  ✓ Multi-criteria scoring: speed (30%) + accuracy (40%) + cost (30%)\")\r\nprint(\"  ✓ Adaptive learning from execution history\")\r\nprint(\"  ✓ Transparent decision explanation\")\r\nprint(\"  ✓ Selects optimal method based on query characteristics\")\r\nprint(\"\\n\" + \"=\"*80 + \"\\n\")\r\n",
    "format": "py"
  }
]