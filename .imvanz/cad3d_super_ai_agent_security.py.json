[
  {
    "timestamp": "2025-11-21T23:23:31.553Z",
    "fileName": "cad3d\\super_ai\\agent_security.py",
    "content": "\"\"\"\r\nAgent Security & Compliance System\r\nØ³ÛŒØ³ØªÙ… Ø§Ù…Ù†ÛŒØªÛŒ Ùˆ Ø§Ù†Ø·Ø¨Ø§Ù‚ Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§\r\n\r\nØ§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø±Ø¹Ø§ÛŒØª Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ø¶ÙˆØ§Ø¨Ø· ØªÙˆØ³Ø· Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ\r\n\"\"\"\r\n\r\nimport logging\r\nfrom typing import Dict, List, Optional, Set\r\nfrom datetime import datetime\r\nfrom enum import Enum\r\nimport json\r\nfrom pathlib import Path\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass ComplianceLevel(Enum):\r\n    \"\"\"Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\"\"\"\r\n    COMPLIANT = \"compliant\"           # Ù…Ø·Ø§Ø¨Ù‚\r\n    WARNING = \"warning\"               # Ù‡Ø´Ø¯Ø§Ø±\r\n    VIOLATION = \"violation\"           # ØªØ®Ù„Ù\r\n    BLOCKED = \"blocked\"               # Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡\r\n\r\nclass ContentCategory(Enum):\r\n    \"\"\"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØªÙˆØ§\"\"\"\r\n    EDUCATIONAL = \"educational\"       # Ø¢Ù…ÙˆØ²Ø´ÛŒ\r\n    RESEARCH = \"research\"             # ØªØ­Ù‚ÛŒÙ‚Ø§ØªÛŒ\r\n    TECHNICAL = \"technical\"           # ÙÙ†ÛŒ\r\n    ADMINISTRATIVE = \"administrative\" # Ø§Ø¯Ø§Ø±ÛŒ\r\n    PROHIBITED = \"prohibited\"         # Ù…Ù…Ù†ÙˆØ¹Ù‡\r\n\r\nclass AgentSecuritySystem:\r\n    \"\"\"\r\n    Ø³ÛŒØ³ØªÙ… Ø§Ù…Ù†ÛŒØªÛŒ Ùˆ Ù†Ø¸Ø§Ø±ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ\r\n    \r\n    Ù…Ø³Ø¦ÙˆÙ„ÛŒØªâ€ŒÙ‡Ø§:\r\n    - Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ØªÙˆØ§ Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡\r\n    - Ù†Ø¸Ø§Ø±Øª Ø¨Ø± Ø±ÙØªØ§Ø± Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§\r\n    - Ø§Ø¹Ù…Ø§Ù„ Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§\r\n    - Ú¯Ø²Ø§Ø±Ø´â€ŒØ¯Ù‡ÛŒ Ùˆ Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ\r\n    \"\"\"\r\n    \r\n    def __init__(self, config_path: Optional[Path] = None):\r\n        self.config = self._load_config(config_path)\r\n        \r\n        # Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§\r\n        self.rules = {\r\n            'allowed_domains': self._get_allowed_domains(),\r\n            'prohibited_keywords': self._get_prohibited_keywords(),\r\n            'allowed_categories': [\r\n                ContentCategory.EDUCATIONAL,\r\n                ContentCategory.RESEARCH,\r\n                ContentCategory.TECHNICAL,\r\n                ContentCategory.ADMINISTRATIVE\r\n            ],\r\n            'max_content_length': 1000000,  # Ø­Ø¯Ø§Ú©Ø«Ø± Ø·ÙˆÙ„ Ù…Ø­ØªÙˆØ§ (Ú©Ø§Ø±Ø§Ú©ØªØ±)\r\n            'required_fields': ['university', 'resource', 'url', 'content']\r\n        }\r\n        \r\n        # Ø¢Ù…Ø§Ø± Ù†Ø¸Ø§Ø±ØªÛŒ\r\n        self.monitoring_stats = {\r\n            'total_checks': 0,\r\n            'compliant': 0,\r\n            'warnings': 0,\r\n            'violations': 0,\r\n            'blocked': 0\r\n        }\r\n        \r\n        # Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ\r\n        self.security_logs = []\r\n        self.logs_dir = Path('university_cache/security_logs')\r\n        self.logs_dir.mkdir(exist_ok=True, parents=True)\r\n    \r\n    def _load_config(self, config_path: Optional[Path]) -> Dict:\r\n        \"\"\"Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª\"\"\"\r\n        if config_path and config_path.exists():\r\n            with open(config_path, 'r', encoding='utf-8') as f:\r\n                return json.load(f)\r\n        \r\n        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶\r\n        return {\r\n            'strict_mode': True,\r\n            'auto_block_violations': True,\r\n            'log_all_checks': False,\r\n            'notify_on_violation': True\r\n        }\r\n    \r\n    def _get_allowed_domains(self) -> Set[str]:\r\n        \"\"\"Ø¯Ø§Ù…Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¬Ø§Ø² Ø¨Ø±Ø§ÛŒ scraping\"\"\"\r\n        return {\r\n            # MIT\r\n            'ocw.mit.edu', 'dspace.mit.edu', 'csail.mit.edu',\r\n            # Stanford\r\n            'online.stanford.edu', 'ai.stanford.edu', 'engineering.stanford.edu',\r\n            # Cambridge\r\n            'repository.cam.ac.uk', 'cam.ac.uk',\r\n            # Oxford\r\n            'ora.ox.ac.uk', 'ox.ac.uk',\r\n            # Berkeley\r\n            'eecs.berkeley.edu', 'bair.berkeley.edu', 'berkeley.edu',\r\n            # ETH Zurich\r\n            'ethz.ch',\r\n            # Caltech\r\n            'caltech.edu',\r\n            # Imperial\r\n            'imperial.ac.uk',\r\n            # Carnegie Mellon\r\n            'cmu.edu',\r\n            # TU Delft\r\n            'tudelft.nl'\r\n        }\r\n    \r\n    def _get_prohibited_keywords(self) -> Set[str]:\r\n        \"\"\"Ú©Ù„Ù…Ø§Øª Ù…Ù…Ù†ÙˆØ¹Ù‡\"\"\"\r\n        return {\r\n            # Ù…Ø­ØªÙˆØ§ÛŒ Ù†Ø§Ù…Ù†Ø§Ø³Ø¨\r\n            'illegal', 'hack', 'crack', 'pirate', 'torrent',\r\n            # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø®ØµÛŒ\r\n            'password', 'credit card', 'ssn', 'social security',\r\n            # Ù…Ø­ØªÙˆØ§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©\r\n            'weapon', 'explosive', 'malware', 'virus',\r\n            # Ø³ÛŒØ§Ø³ÛŒ/Ø¬Ù†Ø¬Ø§Ù„ÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)\r\n            # Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÛŒØ§Ø² Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯\r\n        }\r\n    \r\n    def check_url_compliance(self, url: str) -> ComplianceLevel:\r\n        \"\"\"\r\n        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø·Ø¨Ø§Ù‚ URL\r\n        \r\n        Args:\r\n            url: Ø¢Ø¯Ø±Ø³ URL\r\n        \r\n        Returns:\r\n            Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\r\n        \"\"\"\r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ù…Ù†Ù‡\r\n        from urllib.parse import urlparse\r\n        parsed = urlparse(url)\r\n        domain = parsed.netloc\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ù…Ù†Ù‡ Ø¯Ø± Ù„ÛŒØ³Øª Ù…Ø¬Ø§Ø²\r\n        is_allowed = any(allowed in domain for allowed in self.rules['allowed_domains'])\r\n        \r\n        if not is_allowed:\r\n            self._log_security_event(\r\n                'url_violation',\r\n                f\"Unauthorized domain: {domain}\",\r\n                {'url': url, 'domain': domain}\r\n            )\r\n            return ComplianceLevel.VIOLATION\r\n        \r\n        return ComplianceLevel.COMPLIANT\r\n    \r\n    def check_content_compliance(self, content: str, metadata: Dict) -> ComplianceLevel:\r\n        \"\"\"\r\n        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø·Ø¨Ø§Ù‚ Ù…Ø­ØªÙˆØ§\r\n        \r\n        Args:\r\n            content: Ù…ØªÙ† Ù…Ø­ØªÙˆØ§\r\n            metadata: Ù…ØªØ§Ø¯ÛŒØªØ§\r\n        \r\n        Returns:\r\n            Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\r\n        \"\"\"\r\n        self.monitoring_stats['total_checks'] += 1\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø·ÙˆÙ„ Ù…Ø­ØªÙˆØ§\r\n        if len(content) > self.rules['max_content_length']:\r\n            self._log_security_event(\r\n                'content_length_warning',\r\n                f\"Content too long: {len(content)} chars\",\r\n                metadata\r\n            )\r\n            self.monitoring_stats['warnings'] += 1\r\n            return ComplianceLevel.WARNING\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù„Ù…Ø§Øª Ù…Ù…Ù†ÙˆØ¹Ù‡\r\n        content_lower = content.lower()\r\n        found_prohibited = []\r\n        \r\n        for keyword in self.rules['prohibited_keywords']:\r\n            if keyword in content_lower:\r\n                found_prohibited.append(keyword)\r\n        \r\n        if found_prohibited:\r\n            self._log_security_event(\r\n                'prohibited_content',\r\n                f\"Prohibited keywords found: {', '.join(found_prohibited)}\",\r\n                metadata\r\n            )\r\n            self.monitoring_stats['violations'] += 1\r\n            \r\n            if self.config['auto_block_violations']:\r\n                self.monitoring_stats['blocked'] += 1\r\n                return ComplianceLevel.BLOCKED\r\n            \r\n            return ComplianceLevel.VIOLATION\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ\r\n        for field in self.rules['required_fields']:\r\n            if field not in metadata and field != 'content':\r\n                self._log_security_event(\r\n                    'missing_field',\r\n                    f\"Required field missing: {field}\",\r\n                    metadata\r\n                )\r\n                self.monitoring_stats['warnings'] += 1\r\n                return ComplianceLevel.WARNING\r\n        \r\n        # Ù‡Ù…Ù‡ Ú†ÛŒØ² Ù…Ø·Ø§Ø¨Ù‚ Ø§Ø³Øª\r\n        self.monitoring_stats['compliant'] += 1\r\n        return ComplianceLevel.COMPLIANT\r\n    \r\n    def validate_document(self, document: Dict) -> tuple[bool, ComplianceLevel, str]:\r\n        \"\"\"\r\n        Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ú©Ø§Ù…Ù„ ÛŒÚ© Ø³Ù†Ø¯\r\n        \r\n        Args:\r\n            document: Ø³Ù†Ø¯ Ø´Ø§Ù…Ù„ content Ùˆ metadata\r\n        \r\n        Returns:\r\n            (is_valid, compliance_level, reason)\r\n        \"\"\"\r\n        # Ø¨Ø±Ø±Ø³ÛŒ URL\r\n        if 'url' in document.get('metadata', {}):\r\n            url_compliance = self.check_url_compliance(document['metadata']['url'])\r\n            if url_compliance in [ComplianceLevel.VIOLATION, ComplianceLevel.BLOCKED]:\r\n                return False, url_compliance, \"Invalid URL domain\"\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ØªÙˆØ§\r\n        content = document.get('content', '')\r\n        metadata = document.get('metadata', {})\r\n        \r\n        content_compliance = self.check_content_compliance(content, metadata)\r\n        \r\n        if content_compliance == ComplianceLevel.BLOCKED:\r\n            return False, content_compliance, \"Prohibited content detected\"\r\n        \r\n        if content_compliance == ComplianceLevel.VIOLATION:\r\n            return False, content_compliance, \"Content violation\"\r\n        \r\n        if content_compliance == ComplianceLevel.WARNING:\r\n            # Ù‡Ø´Ø¯Ø§Ø± Ø§Ù…Ø§ Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„\r\n            return True, content_compliance, \"Content accepted with warnings\"\r\n        \r\n        return True, ComplianceLevel.COMPLIANT, \"Document is compliant\"\r\n    \r\n    def _log_security_event(self, event_type: str, message: str, metadata: Dict):\r\n        \"\"\"Ø«Ø¨Øª Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ\"\"\"\r\n        event = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'type': event_type,\r\n            'message': message,\r\n            'metadata': metadata\r\n        }\r\n        \r\n        self.security_logs.append(event)\r\n        \r\n        # Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± ÙØ§ÛŒÙ„\r\n        log_file = self.logs_dir / f\"{datetime.now().strftime('%Y%m%d')}_security.jsonl\"\r\n        with open(log_file, 'a', encoding='utf-8') as f:\r\n            f.write(json.dumps(event, ensure_ascii=False) + '\\n')\r\n        \r\n        # Ù„Ø§Ú¯ Ø¯Ø± console\r\n        if self.config['notify_on_violation'] and event_type in ['prohibited_content', 'url_violation']:\r\n            logger.warning(f\"ðŸš¨ Security Event: {message}\")\r\n    \r\n    def get_monitoring_report(self) -> Dict:\r\n        \"\"\"Ú¯Ø²Ø§Ø±Ø´ Ù†Ø¸Ø§Ø±ØªÛŒ\"\"\"\r\n        total = self.monitoring_stats['total_checks']\r\n        \r\n        return {\r\n            'statistics': self.monitoring_stats,\r\n            'compliance_rate': (\r\n                f\"{100 * self.monitoring_stats['compliant'] / total:.1f}%\"\r\n                if total > 0 else \"0%\"\r\n            ),\r\n            'recent_logs': self.security_logs[-10:],  # 10 Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¢Ø®Ø±\r\n            'config': self.config\r\n        }\r\n    \r\n    def get_agent_score(self, agent_name: str) -> float:\r\n        \"\"\"\r\n        Ø§Ù…ØªÛŒØ§Ø² Ø§Ù†Ø·Ø¨Ø§Ù‚ ÛŒÚ© Ø§ÛŒØ¬Ù†Øª\r\n        \r\n        Returns:\r\n            Ø§Ù…ØªÛŒØ§Ø² Ø¨ÛŒÙ† 0 ØªØ§ 100\r\n        \"\"\"\r\n        # Ø¯Ø± Ù†Ø³Ø®Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¢Ù…Ø§Ø± Ù‡Ø± Ø§ÛŒØ¬Ù†Øª Ø±Ø§ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ù†Ú¯Ù‡ Ø¯Ø§Ø´Øª\r\n        total = self.monitoring_stats['total_checks']\r\n        if total == 0:\r\n            return 100.0\r\n        \r\n        compliant = self.monitoring_stats['compliant']\r\n        warnings = self.monitoring_stats['warnings']\r\n        violations = self.monitoring_stats['violations']\r\n        \r\n        score = 100 * (compliant + 0.5 * warnings) / total\r\n        return max(0.0, min(100.0, score))\r\n\r\n\r\nclass SpecializationManager:\r\n    \"\"\"\r\n    Ù…Ø¯ÛŒØ±ÛŒØª ØªØ®ØµØµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù„Ù…ÛŒ\r\n    \r\n    Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªØ®ØµØµÛŒ Ø¯Ø± Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ ØªØ®ØµØµÛŒ\r\n        self.specializations = {\r\n            'engineering': {\r\n                'civil': ['structural', 'geotechnical', 'transportation', 'hydraulic'],\r\n                'mechanical': ['thermodynamics', 'fluid mechanics', 'manufacturing', 'robotics'],\r\n                'electrical': ['power systems', 'electronics', 'signal processing', 'control'],\r\n                'computer': ['algorithms', 'software engineering', 'AI', 'networks'],\r\n                'chemical': ['process engineering', 'materials', 'thermodynamics'],\r\n                'industrial': ['optimization', 'operations research', 'supply chain'],\r\n                'architecture': ['design', 'urban planning', 'sustainable architecture']\r\n            },\r\n            'management': {\r\n                'business': ['strategy', 'marketing', 'finance', 'operations'],\r\n                'project': ['planning', 'scheduling', 'risk management', 'agile'],\r\n                'hr': ['recruitment', 'training', 'performance', 'organizational behavior'],\r\n                'quality': ['QA/QC', 'six sigma', 'lean', 'ISO standards']\r\n            },\r\n            'economics': {\r\n                'micro': ['consumer theory', 'market structures', 'game theory'],\r\n                'macro': ['monetary policy', 'fiscal policy', 'growth', 'unemployment'],\r\n                'financial': ['investments', 'portfolio theory', 'derivatives', 'risk'],\r\n                'development': ['growth models', 'poverty', 'inequality']\r\n            }\r\n        }\r\n        \r\n        # Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø±Ø´ØªÙ‡\r\n        self.keywords = self._build_keywords()\r\n    \r\n    def _build_keywords(self) -> Dict[str, List[str]]:\r\n        \"\"\"Ø³Ø§Ø®Øª Ù„ÛŒØ³Øª Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ\"\"\"\r\n        keywords = {}\r\n        \r\n        for field, subfields in self.specializations.items():\r\n            keywords[field] = []\r\n            for subfield, topics in subfields.items():\r\n                keywords[field].extend([subfield] + topics)\r\n        \r\n        return keywords\r\n    \r\n    def detect_specialization(self, content: str) -> Dict[str, float]:\r\n        \"\"\"\r\n        ØªØ´Ø®ÛŒØµ ØªØ®ØµØµ Ù…Ø­ØªÙˆØ§\r\n        \r\n        Args:\r\n            content: Ù…ØªÙ† Ù…Ø­ØªÙˆØ§\r\n        \r\n        Returns:\r\n            Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ {field: relevance_score}\r\n        \"\"\"\r\n        content_lower = content.lower()\r\n        scores = {}\r\n        \r\n        for field, field_keywords in self.keywords.items():\r\n            count = sum(1 for keyword in field_keywords if keyword in content_lower)\r\n            scores[field] = count / len(field_keywords) if field_keywords else 0.0\r\n        \r\n        return scores\r\n    \r\n    def get_missing_specializations(self, collected_docs: List[Dict]) -> List[str]:\r\n        \"\"\"\r\n        Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ú©Ù…ØªØ± Ù¾ÙˆØ´Ø´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯\r\n        \r\n        Args:\r\n            collected_docs: Ù„ÛŒØ³Øª Ø§Ø³Ù†Ø§Ø¯ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒâ€ŒØ´Ø¯Ù‡\r\n        \r\n        Returns:\r\n            Ù„ÛŒØ³Øª Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ù¾ÙˆØ´Ø´ Ú©Ù…\r\n        \"\"\"\r\n        specialization_counts = {field: 0 for field in self.specializations.keys()}\r\n        \r\n        for doc in collected_docs:\r\n            content = doc.get('content', '')\r\n            scores = self.detect_specialization(content)\r\n            \r\n            # Ø§Ú¯Ø± Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ÛŒ 0.1 Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ Ø¨Ù‡ Ø¢Ù† Ø±Ø´ØªÙ‡ ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯\r\n            for field, score in scores.items():\r\n                if score > 0.1:\r\n                    specialization_counts[field] += 1\r\n        \r\n        # Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒÛŒ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù…\r\n        avg_count = sum(specialization_counts.values()) / len(specialization_counts)\r\n        missing = [\r\n            field for field, count in specialization_counts.items()\r\n            if count < avg_count * 0.5\r\n        ]\r\n        \r\n        return missing\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:23:31.733Z",
    "fileName": "cad3d\\super_ai\\agent_security.py",
    "content": "\"\"\"\r\nAgent Security & Compliance System\r\nØ³ÛŒØ³ØªÙ… Ø§Ù…Ù†ÛŒØªÛŒ Ùˆ Ø§Ù†Ø·Ø¨Ø§Ù‚ Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§\r\n\r\nØ§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø±Ø¹Ø§ÛŒØª Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ø¶ÙˆØ§Ø¨Ø· ØªÙˆØ³Ø· Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ\r\n\"\"\"\r\n\r\nimport logging\r\nfrom typing import Dict, List, Optional, Set\r\nfrom datetime import datetime\r\nfrom enum import Enum\r\nimport json\r\nfrom pathlib import Path\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nclass ComplianceLevel(Enum):\r\n    \"\"\"Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\"\"\"\r\n    COMPLIANT = \"compliant\"           # Ù…Ø·Ø§Ø¨Ù‚\r\n    WARNING = \"warning\"               # Ù‡Ø´Ø¯Ø§Ø±\r\n    VIOLATION = \"violation\"           # ØªØ®Ù„Ù\r\n    BLOCKED = \"blocked\"               # Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡\r\n\r\nclass ContentCategory(Enum):\r\n    \"\"\"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØªÙˆØ§\"\"\"\r\n    EDUCATIONAL = \"educational\"       # Ø¢Ù…ÙˆØ²Ø´ÛŒ\r\n    RESEARCH = \"research\"             # ØªØ­Ù‚ÛŒÙ‚Ø§ØªÛŒ\r\n    TECHNICAL = \"technical\"           # ÙÙ†ÛŒ\r\n    ADMINISTRATIVE = \"administrative\" # Ø§Ø¯Ø§Ø±ÛŒ\r\n    PROHIBITED = \"prohibited\"         # Ù…Ù…Ù†ÙˆØ¹Ù‡\r\n\r\nclass AgentSecuritySystem:\r\n    \"\"\"\r\n    Ø³ÛŒØ³ØªÙ… Ø§Ù…Ù†ÛŒØªÛŒ Ùˆ Ù†Ø¸Ø§Ø±ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ\r\n    \r\n    Ù…Ø³Ø¦ÙˆÙ„ÛŒØªâ€ŒÙ‡Ø§:\r\n    - Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ØªÙˆØ§ Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡\r\n    - Ù†Ø¸Ø§Ø±Øª Ø¨Ø± Ø±ÙØªØ§Ø± Ø§ÛŒØ¬Ù†Øªâ€ŒÙ‡Ø§\r\n    - Ø§Ø¹Ù…Ø§Ù„ Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§\r\n    - Ú¯Ø²Ø§Ø±Ø´â€ŒØ¯Ù‡ÛŒ Ùˆ Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ\r\n    \"\"\"\r\n    \r\n    def __init__(self, config_path: Optional[Path] = None):\r\n        self.config = self._load_config(config_path)\r\n        \r\n        # Ù‚ÙˆØ§Ù†ÛŒÙ† Ùˆ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§\r\n        self.rules = {\r\n            'allowed_domains': self._get_allowed_domains(),\r\n            'prohibited_keywords': self._get_prohibited_keywords(),\r\n            'allowed_categories': [\r\n                ContentCategory.EDUCATIONAL,\r\n                ContentCategory.RESEARCH,\r\n                ContentCategory.TECHNICAL,\r\n                ContentCategory.ADMINISTRATIVE\r\n            ],\r\n            'max_content_length': 1000000,  # Ø­Ø¯Ø§Ú©Ø«Ø± Ø·ÙˆÙ„ Ù…Ø­ØªÙˆØ§ (Ú©Ø§Ø±Ø§Ú©ØªØ±)\r\n            'required_fields': ['university', 'resource', 'url', 'content']\r\n        }\r\n        \r\n        # Ø¢Ù…Ø§Ø± Ù†Ø¸Ø§Ø±ØªÛŒ\r\n        self.monitoring_stats = {\r\n            'total_checks': 0,\r\n            'compliant': 0,\r\n            'warnings': 0,\r\n            'violations': 0,\r\n            'blocked': 0\r\n        }\r\n        \r\n        # Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ\r\n        self.security_logs = []\r\n        self.logs_dir = Path('university_cache/security_logs')\r\n        self.logs_dir.mkdir(exist_ok=True, parents=True)\r\n    \r\n    def _load_config(self, config_path: Optional[Path]) -> Dict:\r\n        \"\"\"Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª\"\"\"\r\n        if config_path and config_path.exists():\r\n            with open(config_path, 'r', encoding='utf-8') as f:\r\n                return json.load(f)\r\n        \r\n        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶\r\n        return {\r\n            'strict_mode': True,\r\n            'auto_block_violations': True,\r\n            'log_all_checks': False,\r\n            'notify_on_violation': True\r\n        }\r\n    \r\n    def _get_allowed_domains(self) -> Set[str]:\r\n        \"\"\"Ø¯Ø§Ù…Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¬Ø§Ø² Ø¨Ø±Ø§ÛŒ scraping\"\"\"\r\n        return {\r\n            # MIT\r\n            'ocw.mit.edu', 'dspace.mit.edu', 'csail.mit.edu',\r\n            # Stanford\r\n            'online.stanford.edu', 'ai.stanford.edu', 'engineering.stanford.edu',\r\n            # Cambridge\r\n            'repository.cam.ac.uk', 'cam.ac.uk',\r\n            # Oxford\r\n            'ora.ox.ac.uk', 'ox.ac.uk',\r\n            # Berkeley\r\n            'eecs.berkeley.edu', 'bair.berkeley.edu', 'berkeley.edu',\r\n            # ETH Zurich\r\n            'ethz.ch',\r\n            # Caltech\r\n            'caltech.edu',\r\n            # Imperial\r\n            'imperial.ac.uk',\r\n            # Carnegie Mellon\r\n            'cmu.edu',\r\n            # TU Delft\r\n            'tudelft.nl'\r\n        }\r\n    \r\n    def _get_prohibited_keywords(self) -> Set[str]:\r\n        \"\"\"Ú©Ù„Ù…Ø§Øª Ù…Ù…Ù†ÙˆØ¹Ù‡\"\"\"\r\n        return {\r\n            # Ù…Ø­ØªÙˆØ§ÛŒ Ù†Ø§Ù…Ù†Ø§Ø³Ø¨\r\n            'illegal', 'hack', 'crack', 'pirate', 'torrent',\r\n            # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø®ØµÛŒ\r\n            'password', 'credit card', 'ssn', 'social security',\r\n            # Ù…Ø­ØªÙˆØ§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©\r\n            'weapon', 'explosive', 'malware', 'virus',\r\n            # Ø³ÛŒØ§Ø³ÛŒ/Ø¬Ù†Ø¬Ø§Ù„ÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)\r\n            # Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÛŒØ§Ø² Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯\r\n        }\r\n    \r\n    def check_url_compliance(self, url: str) -> ComplianceLevel:\r\n        \"\"\"\r\n        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø·Ø¨Ø§Ù‚ URL\r\n        \r\n        Args:\r\n            url: Ø¢Ø¯Ø±Ø³ URL\r\n        \r\n        Returns:\r\n            Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\r\n        \"\"\"\r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ù…Ù†Ù‡\r\n        from urllib.parse import urlparse\r\n        parsed = urlparse(url)\r\n        domain = parsed.netloc\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ù…Ù†Ù‡ Ø¯Ø± Ù„ÛŒØ³Øª Ù…Ø¬Ø§Ø²\r\n        is_allowed = any(allowed in domain for allowed in self.rules['allowed_domains'])\r\n        \r\n        if not is_allowed:\r\n            self._log_security_event(\r\n                'url_violation',\r\n                f\"Unauthorized domain: {domain}\",\r\n                {'url': url, 'domain': domain}\r\n            )\r\n            return ComplianceLevel.VIOLATION\r\n        \r\n        return ComplianceLevel.COMPLIANT\r\n    \r\n    def check_content_compliance(self, content: str, metadata: Dict) -> ComplianceLevel:\r\n        \"\"\"\r\n        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø·Ø¨Ø§Ù‚ Ù…Ø­ØªÙˆØ§\r\n        \r\n        Args:\r\n            content: Ù…ØªÙ† Ù…Ø­ØªÙˆØ§\r\n            metadata: Ù…ØªØ§Ø¯ÛŒØªØ§\r\n        \r\n        Returns:\r\n            Ø³Ø·Ø­ Ø§Ù†Ø·Ø¨Ø§Ù‚\r\n        \"\"\"\r\n        self.monitoring_stats['total_checks'] += 1\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ø·ÙˆÙ„ Ù…Ø­ØªÙˆØ§\r\n        if len(content) > self.rules['max_content_length']:\r\n            self._log_security_event(\r\n                'content_length_warning',\r\n                f\"Content too long: {len(content)} chars\",\r\n                metadata\r\n            )\r\n            self.monitoring_stats['warnings'] += 1\r\n            return ComplianceLevel.WARNING\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù„Ù…Ø§Øª Ù…Ù…Ù†ÙˆØ¹Ù‡\r\n        content_lower = content.lower()\r\n        found_prohibited = []\r\n        \r\n        for keyword in self.rules['prohibited_keywords']:\r\n            if keyword in content_lower:\r\n                found_prohibited.append(keyword)\r\n        \r\n        if found_prohibited:\r\n            self._log_security_event(\r\n                'prohibited_content',\r\n                f\"Prohibited keywords found: {', '.join(found_prohibited)}\",\r\n                metadata\r\n            )\r\n            self.monitoring_stats['violations'] += 1\r\n            \r\n            if self.config['auto_block_violations']:\r\n                self.monitoring_stats['blocked'] += 1\r\n                return ComplianceLevel.BLOCKED\r\n            \r\n            return ComplianceLevel.VIOLATION\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ\r\n        for field in self.rules['required_fields']:\r\n            if field not in metadata and field != 'content':\r\n                self._log_security_event(\r\n                    'missing_field',\r\n                    f\"Required field missing: {field}\",\r\n                    metadata\r\n                )\r\n                self.monitoring_stats['warnings'] += 1\r\n                return ComplianceLevel.WARNING\r\n        \r\n        # Ù‡Ù…Ù‡ Ú†ÛŒØ² Ù…Ø·Ø§Ø¨Ù‚ Ø§Ø³Øª\r\n        self.monitoring_stats['compliant'] += 1\r\n        return ComplianceLevel.COMPLIANT\r\n    \r\n    def validate_document(self, document: Dict) -> tuple[bool, ComplianceLevel, str]:\r\n        \"\"\"\r\n        Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ú©Ø§Ù…Ù„ ÛŒÚ© Ø³Ù†Ø¯\r\n        \r\n        Args:\r\n            document: Ø³Ù†Ø¯ Ø´Ø§Ù…Ù„ content Ùˆ metadata\r\n        \r\n        Returns:\r\n            (is_valid, compliance_level, reason)\r\n        \"\"\"\r\n        # Ø¨Ø±Ø±Ø³ÛŒ URL\r\n        if 'url' in document.get('metadata', {}):\r\n            url_compliance = self.check_url_compliance(document['metadata']['url'])\r\n            if url_compliance in [ComplianceLevel.VIOLATION, ComplianceLevel.BLOCKED]:\r\n                return False, url_compliance, \"Invalid URL domain\"\r\n        \r\n        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ØªÙˆØ§\r\n        content = document.get('content', '')\r\n        metadata = document.get('metadata', {})\r\n        \r\n        content_compliance = self.check_content_compliance(content, metadata)\r\n        \r\n        if content_compliance == ComplianceLevel.BLOCKED:\r\n            return False, content_compliance, \"Prohibited content detected\"\r\n        \r\n        if content_compliance == ComplianceLevel.VIOLATION:\r\n            return False, content_compliance, \"Content violation\"\r\n        \r\n        if content_compliance == ComplianceLevel.WARNING:\r\n            # Ù‡Ø´Ø¯Ø§Ø± Ø§Ù…Ø§ Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„\r\n            return True, content_compliance, \"Content accepted with warnings\"\r\n        \r\n        return True, ComplianceLevel.COMPLIANT, \"Document is compliant\"\r\n    \r\n    def _log_security_event(self, event_type: str, message: str, metadata: Dict):\r\n        \"\"\"Ø«Ø¨Øª Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ\"\"\"\r\n        event = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'type': event_type,\r\n            'message': message,\r\n            'metadata': metadata\r\n        }\r\n        \r\n        self.security_logs.append(event)\r\n        \r\n        # Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± ÙØ§ÛŒÙ„\r\n        log_file = self.logs_dir / f\"{datetime.now().strftime('%Y%m%d')}_security.jsonl\"\r\n        with open(log_file, 'a', encoding='utf-8') as f:\r\n            f.write(json.dumps(event, ensure_ascii=False) + '\\n')\r\n        \r\n        # Ù„Ø§Ú¯ Ø¯Ø± console\r\n        if self.config['notify_on_violation'] and event_type in ['prohibited_content', 'url_violation']:\r\n            logger.warning(f\"ðŸš¨ Security Event: {message}\")\r\n    \r\n    def get_monitoring_report(self) -> Dict:\r\n        \"\"\"Ú¯Ø²Ø§Ø±Ø´ Ù†Ø¸Ø§Ø±ØªÛŒ\"\"\"\r\n        total = self.monitoring_stats['total_checks']\r\n        \r\n        return {\r\n            'statistics': self.monitoring_stats,\r\n            'compliance_rate': (\r\n                f\"{100 * self.monitoring_stats['compliant'] / total:.1f}%\"\r\n                if total > 0 else \"0%\"\r\n            ),\r\n            'recent_logs': self.security_logs[-10:],  # 10 Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¢Ø®Ø±\r\n            'config': self.config\r\n        }\r\n    \r\n    def get_agent_score(self, agent_name: str) -> float:\r\n        \"\"\"\r\n        Ø§Ù…ØªÛŒØ§Ø² Ø§Ù†Ø·Ø¨Ø§Ù‚ ÛŒÚ© Ø§ÛŒØ¬Ù†Øª\r\n        \r\n        Returns:\r\n            Ø§Ù…ØªÛŒØ§Ø² Ø¨ÛŒÙ† 0 ØªØ§ 100\r\n        \"\"\"\r\n        # Ø¯Ø± Ù†Ø³Ø®Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¢Ù…Ø§Ø± Ù‡Ø± Ø§ÛŒØ¬Ù†Øª Ø±Ø§ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ù†Ú¯Ù‡ Ø¯Ø§Ø´Øª\r\n        total = self.monitoring_stats['total_checks']\r\n        if total == 0:\r\n            return 100.0\r\n        \r\n        compliant = self.monitoring_stats['compliant']\r\n        warnings = self.monitoring_stats['warnings']\r\n        violations = self.monitoring_stats['violations']\r\n        \r\n        score = 100 * (compliant + 0.5 * warnings) / total\r\n        return max(0.0, min(100.0, score))\r\n\r\n\r\nclass SpecializationManager:\r\n    \"\"\"\r\n    Ù…Ø¯ÛŒØ±ÛŒØª ØªØ®ØµØµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù„Ù…ÛŒ\r\n    \r\n    Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªØ®ØµØµÛŒ Ø¯Ø± Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ ØªØ®ØµØµÛŒ\r\n        self.specializations = {\r\n            'engineering': {\r\n                'civil': ['structural', 'geotechnical', 'transportation', 'hydraulic'],\r\n                'mechanical': ['thermodynamics', 'fluid mechanics', 'manufacturing', 'robotics'],\r\n                'electrical': ['power systems', 'electronics', 'signal processing', 'control'],\r\n                'computer': ['algorithms', 'software engineering', 'AI', 'networks'],\r\n                'chemical': ['process engineering', 'materials', 'thermodynamics'],\r\n                'industrial': ['optimization', 'operations research', 'supply chain'],\r\n                'architecture': ['design', 'urban planning', 'sustainable architecture']\r\n            },\r\n            'management': {\r\n                'business': ['strategy', 'marketing', 'finance', 'operations'],\r\n                'project': ['planning', 'scheduling', 'risk management', 'agile'],\r\n                'hr': ['recruitment', 'training', 'performance', 'organizational behavior'],\r\n                'quality': ['QA/QC', 'six sigma', 'lean', 'ISO standards']\r\n            },\r\n            'economics': {\r\n                'micro': ['consumer theory', 'market structures', 'game theory'],\r\n                'macro': ['monetary policy', 'fiscal policy', 'growth', 'unemployment'],\r\n                'financial': ['investments', 'portfolio theory', 'derivatives', 'risk'],\r\n                'development': ['growth models', 'poverty', 'inequality']\r\n            }\r\n        }\r\n        \r\n        # Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø±Ø´ØªÙ‡\r\n        self.keywords = self._build_keywords()\r\n    \r\n    def _build_keywords(self) -> Dict[str, List[str]]:\r\n        \"\"\"Ø³Ø§Ø®Øª Ù„ÛŒØ³Øª Ú©Ù„Ù…Ø§Øª Ú©Ù„ÛŒØ¯ÛŒ\"\"\"\r\n        keywords = {}\r\n        \r\n        for field, subfields in self.specializations.items():\r\n            keywords[field] = []\r\n            for subfield, topics in subfields.items():\r\n                keywords[field].extend([subfield] + topics)\r\n        \r\n        return keywords\r\n    \r\n    def detect_specialization(self, content: str) -> Dict[str, float]:\r\n        \"\"\"\r\n        ØªØ´Ø®ÛŒØµ ØªØ®ØµØµ Ù…Ø­ØªÙˆØ§\r\n        \r\n        Args:\r\n            content: Ù…ØªÙ† Ù…Ø­ØªÙˆØ§\r\n        \r\n        Returns:\r\n            Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ {field: relevance_score}\r\n        \"\"\"\r\n        content_lower = content.lower()\r\n        scores = {}\r\n        \r\n        for field, field_keywords in self.keywords.items():\r\n            count = sum(1 for keyword in field_keywords if keyword in content_lower)\r\n            scores[field] = count / len(field_keywords) if field_keywords else 0.0\r\n        \r\n        return scores\r\n    \r\n    def get_missing_specializations(self, collected_docs: List[Dict]) -> List[str]:\r\n        \"\"\"\r\n        Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ú©Ù…ØªØ± Ù¾ÙˆØ´Ø´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯\r\n        \r\n        Args:\r\n            collected_docs: Ù„ÛŒØ³Øª Ø§Ø³Ù†Ø§Ø¯ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒâ€ŒØ´Ø¯Ù‡\r\n        \r\n        Returns:\r\n            Ù„ÛŒØ³Øª Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ù¾ÙˆØ´Ø´ Ú©Ù…\r\n        \"\"\"\r\n        specialization_counts = {field: 0 for field in self.specializations.keys()}\r\n        \r\n        for doc in collected_docs:\r\n            content = doc.get('content', '')\r\n            scores = self.detect_specialization(content)\r\n            \r\n            # Ø§Ú¯Ø± Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ÛŒ 0.1 Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ Ø¨Ù‡ Ø¢Ù† Ø±Ø´ØªÙ‡ ØªØ¹Ù„Ù‚ Ø¯Ø§Ø±Ø¯\r\n            for field, score in scores.items():\r\n                if score > 0.1:\r\n                    specialization_counts[field] += 1\r\n        \r\n        # Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒÛŒ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù…\r\n        avg_count = sum(specialization_counts.values()) / len(specialization_counts)\r\n        missing = [\r\n            field for field, count in specialization_counts.items()\r\n            if count < avg_count * 0.5\r\n        ]\r\n        \r\n        return missing\r\n",
    "format": "py"
  }
]