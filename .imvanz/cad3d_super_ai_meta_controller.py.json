[
  {
    "timestamp": "2025-11-21T23:02:34.396Z",
    "fileName": "cad3d\\super_ai\\meta_controller.py",
    "content": "\"\"\"\r\nMeta-Controller for Intelligent AI Method Selection\r\n\r\nتحلیل‌گر هوشمند پرسش و انتخاب بهترین روش AI\r\nبر اساس ویژگی‌های ورودی، تخصصی بودن، نیاز به سرعت/دقت\r\n\"\"\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom enum import Enum\r\nimport re\r\n\r\n\r\nclass QueryComplexity(Enum):\r\n    \"\"\"پیچیدگی پرسش\"\"\"\r\n    SIMPLE = \"simple\"           # ساده - محاسبه مستقیم\r\n    MODERATE = \"moderate\"       # متوسط - نیاز به استدلال\r\n    COMPLEX = \"complex\"         # پیچیده - تحلیل چندمرحله‌ای\r\n    VERY_COMPLEX = \"very_complex\"  # بسیار پیچیده - نیاز به تخصص\r\n\r\n\r\nclass QueryUrgency(Enum):\r\n    \"\"\"فوریت پاسخ\"\"\"\r\n    REALTIME = \"realtime\"       # لحظه‌ای < 100ms\r\n    FAST = \"fast\"               # سریع < 1s\r\n    NORMAL = \"normal\"           # عادی < 5s\r\n    BATCH = \"batch\"             # دسته‌ای - بدون محدودیت\r\n\r\n\r\n@dataclass\r\nclass QueryFeatures:\r\n    \"\"\"ویژگی‌های استخراج‌شده از پرسش\"\"\"\r\n    length: int                          # طول متن\r\n    has_numbers: bool                    # شامل اعداد\r\n    has_technical_terms: bool            # اصطلاحات تخصصی\r\n    requires_calculation: bool           # نیاز به محاسبه\r\n    requires_knowledge: bool             # نیاز به دانش پایه\r\n    requires_reasoning: bool             # نیاز به استدلال\r\n    is_specialized: bool                 # تخصصی (معماری، سازه، تاسیسات)\r\n    complexity: QueryComplexity          # پیچیدگی\r\n    urgency: QueryUrgency               # فوریت\r\n    domain: Optional[str]               # حوزه (architecture, structural, MEP, etc.)\r\n    confidence_needed: float            # دقت موردنیاز (0-1)\r\n\r\n\r\n@dataclass\r\nclass MethodScore:\r\n    \"\"\"امتیاز هر روش برای پرسش\"\"\"\r\n    method: str\r\n    score: float                        # امتیاز کلی (0-100)\r\n    speed_score: float                  # امتیاز سرعت\r\n    accuracy_score: float               # امتیاز دقت\r\n    cost_score: float                   # امتیاز هزینه\r\n    reasoning: str                      # دلیل انتخاب\r\n\r\n\r\nclass MetaController:\r\n    \"\"\"\r\n    کنترلر هوشمند انتخاب روش AI\r\n    \r\n    تحلیل ویژگی‌های پرسش:\r\n    - طول و پیچیدگی\r\n    - تخصصی بودن\r\n    - نیاز به داده به‌روز\r\n    - سرعت پاسخ\r\n    - حساسیت به خطا\r\n    \r\n    تصمیم‌گیری بر اساس:\r\n    - امتیازدهی چندمعیاره\r\n    - قوانین خبره\r\n    - تاریخچه عملکرد\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # الگوهای تشخیص\r\n        self.number_pattern = re.compile(r'\\d+\\.?\\d*')\r\n        self.calculation_keywords = [\r\n            \"محاسبه\", \"حساب\", \"چقدر\", \"چند\", \"جمع\", \"تفریق\", \"ضرب\", \"تقسیم\",\r\n            \"calculate\", \"compute\", \"how much\", \"how many\", \"sum\", \"total\"\r\n        ]\r\n        self.technical_terms = [\r\n            \"معماری\", \"سازه\", \"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"بتن\", \"فولاد\",\r\n            \"architecture\", \"structural\", \"mep\", \"hvac\", \"concrete\", \"steel\", \"beam\", \"column\"\r\n        ]\r\n        self.knowledge_keywords = [\r\n            \"استاندارد\", \"ضابطه\", \"مبحث\", \"قانون\", \"آیین‌نامه\", \"تعریف\", \"چیست\",\r\n            \"standard\", \"code\", \"regulation\", \"definition\", \"what is\", \"explain\"\r\n        ]\r\n        self.reasoning_keywords = [\r\n            \"تحلیل\", \"بررسی\", \"مقایسه\", \"ارزیابی\", \"بهینه\", \"پیشنهاد\", \"چرا\",\r\n            \"analyze\", \"compare\", \"evaluate\", \"optimize\", \"suggest\", \"why\", \"because\"\r\n        ]\r\n        \r\n        # وزن‌ها برای تصمیم‌گیری (قابل تنظیم)\r\n        self.weights = {\r\n            \"speed\": 0.3,      # اهمیت سرعت\r\n            \"accuracy\": 0.4,   # اهمیت دقت\r\n            \"cost\": 0.3        # اهمیت هزینه\r\n        }\r\n        \r\n        # آمار عملکرد روش‌ها (برای یادگیری)\r\n        self.method_performance = {\r\n            \"RAG\": {\"success_rate\": 0.95, \"avg_time\": 0.5},\r\n            \"Fine-Tuning\": {\"success_rate\": 0.98, \"avg_time\": 1.2},\r\n            \"LoRA\": {\"success_rate\": 0.92, \"avg_time\": 0.8},\r\n            \"Prompt Engineering\": {\"success_rate\": 0.85, \"avg_time\": 0.3},\r\n            \"PEFT\": {\"success_rate\": 0.90, \"avg_time\": 0.6}\r\n        }\r\n    \r\n    def analyze_query(self, query: str, task_type: Optional[str] = None) -> QueryFeatures:\r\n        \"\"\"\r\n        تحلیل کامل پرسش و استخراج ویژگی‌ها\r\n        \r\n        Args:\r\n            query: متن پرسش\r\n            task_type: نوع وظیفه (اختیاری)\r\n        \r\n        Returns:\r\n            ویژگی‌های استخراج‌شده\r\n        \"\"\"\r\n        query_lower = query.lower()\r\n        \r\n        # طول و اعداد\r\n        length = len(query)\r\n        has_numbers = bool(self.number_pattern.search(query))\r\n        \r\n        # تشخیص نیازها\r\n        requires_calculation = any(kw in query_lower for kw in self.calculation_keywords)\r\n        requires_knowledge = any(kw in query_lower for kw in self.knowledge_keywords)\r\n        requires_reasoning = any(kw in query_lower for kw in self.reasoning_keywords)\r\n        \r\n        # تخصصی بودن\r\n        has_technical_terms = any(term in query_lower for term in self.technical_terms)\r\n        is_specialized = has_technical_terms or (task_type and task_type in [\r\n            \"CAD_ANALYSIS\", \"STRUCTURAL_CALCULATION\", \"MEP_OPTIMIZATION\"\r\n        ])\r\n        \r\n        # تشخیص حوزه\r\n        domain = self._detect_domain(query_lower)\r\n        \r\n        # پیچیدگی\r\n        complexity = self._assess_complexity(\r\n            length, has_numbers, requires_calculation,\r\n            requires_knowledge, requires_reasoning, is_specialized\r\n        )\r\n        \r\n        # فوریت (پیش‌فرض بر اساس پیچیدگی)\r\n        urgency = self._assess_urgency(complexity, requires_calculation)\r\n        \r\n        # دقت موردنیاز\r\n        confidence_needed = self._assess_confidence_requirement(\r\n            requires_calculation, is_specialized, has_numbers\r\n        )\r\n        \r\n        return QueryFeatures(\r\n            length=length,\r\n            has_numbers=has_numbers,\r\n            has_technical_terms=has_technical_terms,\r\n            requires_calculation=requires_calculation,\r\n            requires_knowledge=requires_knowledge,\r\n            requires_reasoning=requires_reasoning,\r\n            is_specialized=is_specialized,\r\n            complexity=complexity,\r\n            urgency=urgency,\r\n            domain=domain,\r\n            confidence_needed=confidence_needed\r\n        )\r\n    \r\n    def _detect_domain(self, query_lower: str) -> Optional[str]:\r\n        \"\"\"تشخیص حوزه تخصصی\"\"\"\r\n        domains = {\r\n            \"architecture\": [\"معماری\", \"طراحی\", \"اتاق\", \"خانه\", \"ساختمان\", \"فضا\", \"architecture\", \"design\", \"room\", \"building\"],\r\n            \"structural\": [\"سازه\", \"تیر\", \"ستون\", \"بتن\", \"فولاد\", \"structural\", \"beam\", \"column\", \"concrete\", \"steel\"],\r\n            \"mep\": [\"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"mep\", \"hvac\", \"electrical\", \"plumbing\"],\r\n            \"calculation\": [\"محاسبه\", \"حساب\", \"عدد\", \"calculate\", \"compute\", \"number\"],\r\n            \"general\": []\r\n        }\r\n        \r\n        for domain, keywords in domains.items():\r\n            if any(kw in query_lower for kw in keywords):\r\n                return domain\r\n        \r\n        return \"general\"\r\n    \r\n    def _assess_complexity(\r\n        self,\r\n        length: int,\r\n        has_numbers: bool,\r\n        requires_calculation: bool,\r\n        requires_knowledge: bool,\r\n        requires_reasoning: bool,\r\n        is_specialized: bool\r\n    ) -> QueryComplexity:\r\n        \"\"\"ارزیابی پیچیدگی پرسش\"\"\"\r\n        \r\n        score = 0\r\n        \r\n        # طول\r\n        if length > 200: score += 2\r\n        elif length > 100: score += 1\r\n        \r\n        # نیازها\r\n        if requires_calculation: score += 1\r\n        if requires_knowledge: score += 1\r\n        if requires_reasoning: score += 2\r\n        if is_specialized: score += 2\r\n        if has_numbers and requires_calculation: score += 1\r\n        \r\n        if score >= 6:\r\n            return QueryComplexity.VERY_COMPLEX\r\n        elif score >= 4:\r\n            return QueryComplexity.COMPLEX\r\n        elif score >= 2:\r\n            return QueryComplexity.MODERATE\r\n        else:\r\n            return QueryComplexity.SIMPLE\r\n    \r\n    def _assess_urgency(self, complexity: QueryComplexity, requires_calculation: bool) -> QueryUrgency:\r\n        \"\"\"ارزیابی فوریت پاسخ\"\"\"\r\n        \r\n        # محاسبات ساده نیاز به سرعت بالا دارند\r\n        if requires_calculation and complexity == QueryComplexity.SIMPLE:\r\n            return QueryUrgency.FAST\r\n        \r\n        # پرسش‌های پیچیده می‌توانند کندتر باشند\r\n        if complexity == QueryComplexity.VERY_COMPLEX:\r\n            return QueryUrgency.BATCH\r\n        elif complexity == QueryComplexity.COMPLEX:\r\n            return QueryUrgency.NORMAL\r\n        else:\r\n            return QueryUrgency.FAST\r\n    \r\n    def _assess_confidence_requirement(\r\n        self,\r\n        requires_calculation: bool,\r\n        is_specialized: bool,\r\n        has_numbers: bool\r\n    ) -> float:\r\n        \"\"\"ارزیابی سطح دقت موردنیاز (0-1)\"\"\"\r\n        \r\n        confidence = 0.7  # پایه\r\n        \r\n        if requires_calculation: confidence += 0.15\r\n        if is_specialized: confidence += 0.10\r\n        if has_numbers: confidence += 0.05\r\n        \r\n        return min(confidence, 1.0)\r\n    \r\n    def select_best_method(\r\n        self,\r\n        features: QueryFeatures,\r\n        available_methods: Optional[List[str]] = None\r\n    ) -> Tuple[str, MethodScore]:\r\n        \"\"\"\r\n        انتخاب بهترین روش بر اساس ویژگی‌های پرسش\r\n        \r\n        Args:\r\n            features: ویژگی‌های پرسش\r\n            available_methods: روش‌های در دسترس (همه اگر None)\r\n        \r\n        Returns:\r\n            (روش انتخاب‌شده, امتیازات)\r\n        \"\"\"\r\n        \r\n        if available_methods is None:\r\n            available_methods = [\"RAG\", \"Fine-Tuning\", \"LoRA\", \"Prompt Engineering\", \"PEFT\"]\r\n        \r\n        # محاسبه امتیاز هر روش\r\n        scores = []\r\n        \r\n        for method in available_methods:\r\n            score = self._score_method(method, features)\r\n            scores.append(score)\r\n        \r\n        # مرتب‌سازی بر اساس امتیاز کلی\r\n        scores.sort(key=lambda x: x.score, reverse=True)\r\n        \r\n        best_method = scores[0].method\r\n        best_score = scores[0]\r\n        \r\n        return best_method, best_score\r\n    \r\n    def _score_method(self, method: str, features: QueryFeatures) -> MethodScore:\r\n        \"\"\"محاسبه امتیاز یک روش برای پرسش\"\"\"\r\n        \r\n        # امتیازات پایه هر روش\r\n        base_scores = {\r\n            \"RAG\": {\r\n                \"speed\": 85,      # سریع\r\n                \"accuracy\": 90,   # دقیق (با منابع)\r\n                \"cost\": 90        # ارزان\r\n            },\r\n            \"Fine-Tuning\": {\r\n                \"speed\": 70,      # کندتر\r\n                \"accuracy\": 95,   # بسیار دقیق\r\n                \"cost\": 40        # گران\r\n            },\r\n            \"LoRA\": {\r\n                \"speed\": 75,      # متوسط\r\n                \"accuracy\": 88,   # خوب\r\n                \"cost\": 70        # متوسط\r\n            },\r\n            \"Prompt Engineering\": {\r\n                \"speed\": 95,      # خیلی سریع\r\n                \"accuracy\": 75,   # متوسط\r\n                \"cost\": 95        # خیلی ارزان\r\n            },\r\n            \"PEFT\": {\r\n                \"speed\": 80,      # سریع\r\n                \"accuracy\": 85,   # خوب\r\n                \"cost\": 80        # ارزان\r\n            }\r\n        }\r\n        \r\n        scores = base_scores[method].copy()\r\n        reasoning_parts = []\r\n        \r\n        # تنظیمات بر اساس ویژگی‌های پرسش\r\n        \r\n        # RAG برای دانش و محاسبات عالی است\r\n        if method == \"RAG\":\r\n            if features.requires_knowledge:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"نیاز به دانش پایه\")\r\n            if features.requires_calculation:\r\n                scores[\"accuracy\"] += 3\r\n                reasoning_parts.append(\"محاسبه با منابع\")\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پاسخ سریع\")\r\n        \r\n        # Fine-Tuning برای کارهای تخصصی پیچیده\r\n        elif method == \"Fine-Tuning\":\r\n            if features.is_specialized:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"تخصصی\")\r\n            if features.complexity in [QueryComplexity.COMPLEX, QueryComplexity.VERY_COMPLEX]:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] -= 10  # کندتر اما دقیق‌تر\r\n                reasoning_parts.append(\"پیچیدگی بالا\")\r\n            if features.confidence_needed > 0.9:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"نیاز به دقت بالا\")\r\n            if features.urgency == QueryUrgency.BATCH:\r\n                scores[\"speed\"] += 10  # زمان مهم نیست\r\n            if features.requires_reasoning:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"استدلال پیچیده\")\r\n        \r\n        # LoRA برای تطبیق سریع\r\n        elif method == \"LoRA\":\r\n            if features.is_specialized and features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"تخصصی متوسط\")\r\n            if features.domain in [\"structural\", \"mep\"]:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(f\"حوزه {features.domain}\")\r\n            if features.requires_calculation and features.is_specialized:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"محاسبه تخصصی\")\r\n        \r\n        # Prompt Engineering برای سرعت\r\n        elif method == \"Prompt Engineering\":\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"نیاز به سرعت\")\r\n            if features.complexity == QueryComplexity.SIMPLE:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پرسش ساده\")\r\n            if not features.is_specialized:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"عمومی\")\r\n            if not features.requires_reasoning:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"بدون استدلال پیچیده\")\r\n        \r\n        # PEFT برای کارآیی\r\n        elif method == \"PEFT\":\r\n            if features.is_specialized and features.confidence_needed > 0.8:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"تخصصی با دقت\")\r\n            if features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"پیچیدگی متوسط\")\r\n            if features.domain == \"mep\":\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"مناسب MEP\")\r\n        \r\n        # محاسبه امتیاز نهایی\r\n        speed_score = min(scores[\"speed\"], 100)\r\n        accuracy_score = min(scores[\"accuracy\"], 100)\r\n        cost_score = min(scores[\"cost\"], 100)\r\n        \r\n        # امتیاز وزن‌دار\r\n        final_score = (\r\n            speed_score * self.weights[\"speed\"] +\r\n            accuracy_score * self.weights[\"accuracy\"] +\r\n            cost_score * self.weights[\"cost\"]\r\n        )\r\n        \r\n        # اضافه کردن تاریخچه عملکرد (با وزن کمتر)\r\n        perf = self.method_performance[method]\r\n        performance_factor = 0.7 + (perf[\"success_rate\"] * 0.3)  # 70% base + 30% history\r\n        final_score *= performance_factor\r\n        \r\n        reasoning = f\"{method}: \" + \", \".join(reasoning_parts) if reasoning_parts else f\"{method}: امتیاز پایه\"\r\n        \r\n        return MethodScore(\r\n            method=method,\r\n            score=final_score,\r\n            speed_score=speed_score,\r\n            accuracy_score=accuracy_score,\r\n            cost_score=cost_score,\r\n            reasoning=reasoning\r\n        )\r\n    \r\n    def explain_decision(\r\n        self,\r\n        query: str,\r\n        features: QueryFeatures,\r\n        selected_method: str,\r\n        score: MethodScore,\r\n        all_scores: Optional[List[MethodScore]] = None\r\n    ) -> Dict:\r\n        \"\"\"\r\n        توضیح دلیل انتخاب روش\r\n        \r\n        Returns:\r\n            توضیحات کامل تصمیم\r\n        \"\"\"\r\n        \r\n        explanation = {\r\n            \"query\": query,\r\n            \"selected_method\": selected_method,\r\n            \"reasoning\": score.reasoning,\r\n            \"features\": {\r\n                \"complexity\": features.complexity.value,\r\n                \"urgency\": features.urgency.value,\r\n                \"domain\": features.domain,\r\n                \"requires_knowledge\": features.requires_knowledge,\r\n                \"requires_calculation\": features.requires_calculation,\r\n                \"is_specialized\": features.is_specialized,\r\n                \"confidence_needed\": f\"{features.confidence_needed:.0%}\"\r\n            },\r\n            \"scores\": {\r\n                \"final\": f\"{score.score:.1f}\",\r\n                \"speed\": f\"{score.speed_score:.1f}\",\r\n                \"accuracy\": f\"{score.accuracy_score:.1f}\",\r\n                \"cost\": f\"{score.cost_score:.1f}\"\r\n            }\r\n        }\r\n        \r\n        if all_scores:\r\n            explanation[\"alternatives\"] = [\r\n                {\r\n                    \"method\": s.method,\r\n                    \"score\": f\"{s.score:.1f}\",\r\n                    \"reasoning\": s.reasoning\r\n                }\r\n                for s in all_scores[:3]  # تاپ 3\r\n            ]\r\n        \r\n        return explanation\r\n    \r\n    def update_performance(self, method: str, success: bool, execution_time: float):\r\n        \"\"\"به‌روزرسانی آمار عملکرد برای یادگیری\"\"\"\r\n        \r\n        if method not in self.method_performance:\r\n            return\r\n        \r\n        perf = self.method_performance[method]\r\n        \r\n        # به‌روزرسانی نرخ موفقیت (با میانگین متحرک)\r\n        alpha = 0.1  # ضریب یادگیری\r\n        perf[\"success_rate\"] = (\r\n            (1 - alpha) * perf[\"success_rate\"] +\r\n            alpha * (1.0 if success else 0.0)\r\n        )\r\n        \r\n        # به‌روزرسانی زمان متوسط\r\n        perf[\"avg_time\"] = (\r\n            (1 - alpha) * perf[\"avg_time\"] +\r\n            alpha * execution_time\r\n        )\r\n    \r\n    def get_performance_stats(self) -> Dict:\r\n        \"\"\"دریافت آمار عملکرد همه روش‌ها\"\"\"\r\n        return {\r\n            method: {\r\n                \"success_rate\": f\"{stats['success_rate']:.1%}\",\r\n                \"avg_time\": f\"{stats['avg_time']:.2f}s\"\r\n            }\r\n            for method, stats in self.method_performance.items()\r\n        }\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:03:29.500Z",
    "fileName": "cad3d\\super_ai\\meta_controller.py",
    "content": "\"\"\"\r\nMeta-Controller for Intelligent AI Method Selection\r\n\r\nتحلیل‌گر هوشمند پرسش و انتخاب بهترین روش AI\r\nبر اساس ویژگی‌های ورودی، تخصصی بودن، نیاز به سرعت/دقت\r\n\"\"\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom enum import Enum\r\nimport re\r\n\r\n\r\nclass QueryComplexity(Enum):\r\n    \"\"\"پیچیدگی پرسش\"\"\"\r\n    SIMPLE = \"simple\"           # ساده - محاسبه مستقیم\r\n    MODERATE = \"moderate\"       # متوسط - نیاز به استدلال\r\n    COMPLEX = \"complex\"         # پیچیده - تحلیل چندمرحله‌ای\r\n    VERY_COMPLEX = \"very_complex\"  # بسیار پیچیده - نیاز به تخصص\r\n\r\n\r\nclass QueryUrgency(Enum):\r\n    \"\"\"فوریت پاسخ\"\"\"\r\n    REALTIME = \"realtime\"       # لحظه‌ای < 100ms\r\n    FAST = \"fast\"               # سریع < 1s\r\n    NORMAL = \"normal\"           # عادی < 5s\r\n    BATCH = \"batch\"             # دسته‌ای - بدون محدودیت\r\n\r\n\r\n@dataclass\r\nclass QueryFeatures:\r\n    \"\"\"ویژگی‌های استخراج‌شده از پرسش\"\"\"\r\n    length: int                          # طول متن\r\n    has_numbers: bool                    # شامل اعداد\r\n    has_technical_terms: bool            # اصطلاحات تخصصی\r\n    requires_calculation: bool           # نیاز به محاسبه\r\n    requires_knowledge: bool             # نیاز به دانش پایه\r\n    requires_reasoning: bool             # نیاز به استدلال\r\n    is_specialized: bool                 # تخصصی (معماری، سازه، تاسیسات)\r\n    complexity: QueryComplexity          # پیچیدگی\r\n    urgency: QueryUrgency               # فوریت\r\n    domain: Optional[str]               # حوزه (architecture, structural, MEP, etc.)\r\n    confidence_needed: float            # دقت موردنیاز (0-1)\r\n\r\n\r\n@dataclass\r\nclass MethodScore:\r\n    \"\"\"امتیاز هر روش برای پرسش\"\"\"\r\n    method: str\r\n    score: float                        # امتیاز کلی (0-100)\r\n    speed_score: float                  # امتیاز سرعت\r\n    accuracy_score: float               # امتیاز دقت\r\n    cost_score: float                   # امتیاز هزینه\r\n    reasoning: str                      # دلیل انتخاب\r\n\r\n\r\nclass MetaController:\r\n    \"\"\"\r\n    کنترلر هوشمند انتخاب روش AI\r\n    \r\n    تحلیل ویژگی‌های پرسش:\r\n    - طول و پیچیدگی\r\n    - تخصصی بودن\r\n    - نیاز به داده به‌روز\r\n    - سرعت پاسخ\r\n    - حساسیت به خطا\r\n    \r\n    تصمیم‌گیری بر اساس:\r\n    - امتیازدهی چندمعیاره\r\n    - قوانین خبره\r\n    - تاریخچه عملکرد\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # الگوهای تشخیص\r\n        self.number_pattern = re.compile(r'\\d+\\.?\\d*')\r\n        self.calculation_keywords = [\r\n            \"محاسبه\", \"حساب\", \"چقدر\", \"چند\", \"جمع\", \"تفریق\", \"ضرب\", \"تقسیم\",\r\n            \"calculate\", \"compute\", \"how much\", \"how many\", \"sum\", \"total\"\r\n        ]\r\n        self.technical_terms = [\r\n            \"معماری\", \"سازه\", \"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"بتن\", \"فولاد\",\r\n            \"architecture\", \"structural\", \"mep\", \"hvac\", \"concrete\", \"steel\", \"beam\", \"column\"\r\n        ]\r\n        self.knowledge_keywords = [\r\n            \"استاندارد\", \"ضابطه\", \"مبحث\", \"قانون\", \"آیین‌نامه\", \"تعریف\", \"چیست\",\r\n            \"بهینه\", \"طراحی\", \"ساختار\", \"ساختمان\", \"سازه‌ای\",\r\n            \"standard\", \"code\", \"regulation\", \"definition\", \"what is\", \"explain\",\r\n            \"design\", \"structure\", \"building\", \"structural\", \"optimize\", \"optimization\"\r\n        ]\r\n        self.reasoning_keywords = [\r\n            \"تحلیل\", \"بررسی\", \"مقایسه\", \"ارزیابی\", \"بهینه\", \"پیشنهاد\", \"چرا\",\r\n            \"analyze\", \"compare\", \"evaluate\", \"optimize\", \"suggest\", \"why\", \"because\"\r\n        ]\r\n        \r\n        # وزن‌ها برای تصمیم‌گیری (قابل تنظیم)\r\n        self.weights = {\r\n            \"speed\": 0.3,      # اهمیت سرعت\r\n            \"accuracy\": 0.4,   # اهمیت دقت\r\n            \"cost\": 0.3        # اهمیت هزینه\r\n        }\r\n        \r\n        # آمار عملکرد روش‌ها (برای یادگیری)\r\n        self.method_performance = {\r\n            \"RAG\": {\"success_rate\": 0.95, \"avg_time\": 0.5},\r\n            \"Fine-Tuning\": {\"success_rate\": 0.98, \"avg_time\": 1.2},\r\n            \"LoRA\": {\"success_rate\": 0.92, \"avg_time\": 0.8},\r\n            \"Prompt Engineering\": {\"success_rate\": 0.85, \"avg_time\": 0.3},\r\n            \"PEFT\": {\"success_rate\": 0.90, \"avg_time\": 0.6}\r\n        }\r\n    \r\n    def analyze_query(self, query: str, task_type: Optional[str] = None) -> QueryFeatures:\r\n        \"\"\"\r\n        تحلیل کامل پرسش و استخراج ویژگی‌ها\r\n        \r\n        Args:\r\n            query: متن پرسش\r\n            task_type: نوع وظیفه (اختیاری)\r\n        \r\n        Returns:\r\n            ویژگی‌های استخراج‌شده\r\n        \"\"\"\r\n        query_lower = query.lower()\r\n        \r\n        # طول و اعداد\r\n        length = len(query)\r\n        has_numbers = bool(self.number_pattern.search(query))\r\n        \r\n        # تشخیص نیازها\r\n        requires_calculation = any(kw in query_lower for kw in self.calculation_keywords)\r\n        requires_knowledge = any(kw in query_lower for kw in self.knowledge_keywords)\r\n        requires_reasoning = any(kw in query_lower for kw in self.reasoning_keywords)\r\n        \r\n        # تخصصی بودن\r\n        has_technical_terms = any(term in query_lower for term in self.technical_terms)\r\n        is_specialized = has_technical_terms or (task_type and task_type in [\r\n            \"CAD_ANALYSIS\", \"STRUCTURAL_CALCULATION\", \"MEP_OPTIMIZATION\"\r\n        ])\r\n        \r\n        # تشخیص حوزه\r\n        domain = self._detect_domain(query_lower)\r\n        \r\n        # پیچیدگی\r\n        complexity = self._assess_complexity(\r\n            length, has_numbers, requires_calculation,\r\n            requires_knowledge, requires_reasoning, is_specialized\r\n        )\r\n        \r\n        # فوریت (پیش‌فرض بر اساس پیچیدگی)\r\n        urgency = self._assess_urgency(complexity, requires_calculation)\r\n        \r\n        # دقت موردنیاز\r\n        confidence_needed = self._assess_confidence_requirement(\r\n            requires_calculation, is_specialized, has_numbers\r\n        )\r\n        \r\n        return QueryFeatures(\r\n            length=length,\r\n            has_numbers=has_numbers,\r\n            has_technical_terms=has_technical_terms,\r\n            requires_calculation=requires_calculation,\r\n            requires_knowledge=requires_knowledge,\r\n            requires_reasoning=requires_reasoning,\r\n            is_specialized=is_specialized,\r\n            complexity=complexity,\r\n            urgency=urgency,\r\n            domain=domain,\r\n            confidence_needed=confidence_needed\r\n        )\r\n    \r\n    def _detect_domain(self, query_lower: str) -> Optional[str]:\r\n        \"\"\"تشخیص حوزه تخصصی\"\"\"\r\n        domains = {\r\n            \"architecture\": [\"معماری\", \"طراحی\", \"اتاق\", \"خانه\", \"ساختمان\", \"فضا\", \"architecture\", \"design\", \"room\", \"building\"],\r\n            \"structural\": [\"سازه\", \"تیر\", \"ستون\", \"بتن\", \"فولاد\", \"structural\", \"beam\", \"column\", \"concrete\", \"steel\"],\r\n            \"mep\": [\"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"mep\", \"hvac\", \"electrical\", \"plumbing\"],\r\n            \"calculation\": [\"محاسبه\", \"حساب\", \"عدد\", \"calculate\", \"compute\", \"number\"],\r\n            \"general\": []\r\n        }\r\n        \r\n        for domain, keywords in domains.items():\r\n            if any(kw in query_lower for kw in keywords):\r\n                return domain\r\n        \r\n        return \"general\"\r\n    \r\n    def _assess_complexity(\r\n        self,\r\n        length: int,\r\n        has_numbers: bool,\r\n        requires_calculation: bool,\r\n        requires_knowledge: bool,\r\n        requires_reasoning: bool,\r\n        is_specialized: bool\r\n    ) -> QueryComplexity:\r\n        \"\"\"ارزیابی پیچیدگی پرسش\"\"\"\r\n        \r\n        score = 0\r\n        \r\n        # طول\r\n        if length > 200: score += 2\r\n        elif length > 100: score += 1\r\n        \r\n        # نیازها\r\n        if requires_calculation: score += 1\r\n        if requires_knowledge: score += 1\r\n        if requires_reasoning: score += 2\r\n        if is_specialized: score += 2\r\n        if has_numbers and requires_calculation: score += 1\r\n        \r\n        if score >= 6:\r\n            return QueryComplexity.VERY_COMPLEX\r\n        elif score >= 4:\r\n            return QueryComplexity.COMPLEX\r\n        elif score >= 2:\r\n            return QueryComplexity.MODERATE\r\n        else:\r\n            return QueryComplexity.SIMPLE\r\n    \r\n    def _assess_urgency(self, complexity: QueryComplexity, requires_calculation: bool) -> QueryUrgency:\r\n        \"\"\"ارزیابی فوریت پاسخ\"\"\"\r\n        \r\n        # محاسبات ساده نیاز به سرعت بالا دارند\r\n        if requires_calculation and complexity == QueryComplexity.SIMPLE:\r\n            return QueryUrgency.FAST\r\n        \r\n        # پرسش‌های پیچیده می‌توانند کندتر باشند\r\n        if complexity == QueryComplexity.VERY_COMPLEX:\r\n            return QueryUrgency.BATCH\r\n        elif complexity == QueryComplexity.COMPLEX:\r\n            return QueryUrgency.NORMAL\r\n        else:\r\n            return QueryUrgency.FAST\r\n    \r\n    def _assess_confidence_requirement(\r\n        self,\r\n        requires_calculation: bool,\r\n        is_specialized: bool,\r\n        has_numbers: bool\r\n    ) -> float:\r\n        \"\"\"ارزیابی سطح دقت موردنیاز (0-1)\"\"\"\r\n        \r\n        confidence = 0.7  # پایه\r\n        \r\n        if requires_calculation: confidence += 0.15\r\n        if is_specialized: confidence += 0.10\r\n        if has_numbers: confidence += 0.05\r\n        \r\n        return min(confidence, 1.0)\r\n    \r\n    def select_best_method(\r\n        self,\r\n        features: QueryFeatures,\r\n        available_methods: Optional[List[str]] = None\r\n    ) -> Tuple[str, MethodScore]:\r\n        \"\"\"\r\n        انتخاب بهترین روش بر اساس ویژگی‌های پرسش\r\n        \r\n        Args:\r\n            features: ویژگی‌های پرسش\r\n            available_methods: روش‌های در دسترس (همه اگر None)\r\n        \r\n        Returns:\r\n            (روش انتخاب‌شده, امتیازات)\r\n        \"\"\"\r\n        \r\n        if available_methods is None:\r\n            available_methods = [\"RAG\", \"Fine-Tuning\", \"LoRA\", \"Prompt Engineering\", \"PEFT\"]\r\n        \r\n        # محاسبه امتیاز هر روش\r\n        scores = []\r\n        \r\n        for method in available_methods:\r\n            score = self._score_method(method, features)\r\n            scores.append(score)\r\n        \r\n        # مرتب‌سازی بر اساس امتیاز کلی\r\n        scores.sort(key=lambda x: x.score, reverse=True)\r\n        \r\n        best_method = scores[0].method\r\n        best_score = scores[0]\r\n        \r\n        return best_method, best_score\r\n    \r\n    def _score_method(self, method: str, features: QueryFeatures) -> MethodScore:\r\n        \"\"\"محاسبه امتیاز یک روش برای پرسش\"\"\"\r\n        \r\n        # امتیازات پایه هر روش\r\n        base_scores = {\r\n            \"RAG\": {\r\n                \"speed\": 85,      # سریع\r\n                \"accuracy\": 90,   # دقیق (با منابع)\r\n                \"cost\": 90        # ارزان\r\n            },\r\n            \"Fine-Tuning\": {\r\n                \"speed\": 70,      # کندتر\r\n                \"accuracy\": 95,   # بسیار دقیق\r\n                \"cost\": 40        # گران\r\n            },\r\n            \"LoRA\": {\r\n                \"speed\": 75,      # متوسط\r\n                \"accuracy\": 88,   # خوب\r\n                \"cost\": 70        # متوسط\r\n            },\r\n            \"Prompt Engineering\": {\r\n                \"speed\": 95,      # خیلی سریع\r\n                \"accuracy\": 75,   # متوسط\r\n                \"cost\": 95        # خیلی ارزان\r\n            },\r\n            \"PEFT\": {\r\n                \"speed\": 80,      # سریع\r\n                \"accuracy\": 85,   # خوب\r\n                \"cost\": 80        # ارزان\r\n            }\r\n        }\r\n        \r\n        scores = base_scores[method].copy()\r\n        reasoning_parts = []\r\n        \r\n        # تنظیمات بر اساس ویژگی‌های پرسش\r\n        \r\n        # RAG برای دانش و محاسبات عالی است\r\n        if method == \"RAG\":\r\n            if features.requires_knowledge:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"نیاز به دانش پایه\")\r\n            if features.requires_calculation:\r\n                scores[\"accuracy\"] += 3\r\n                reasoning_parts.append(\"محاسبه با منابع\")\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پاسخ سریع\")\r\n        \r\n        # Fine-Tuning برای کارهای تخصصی پیچیده\r\n        elif method == \"Fine-Tuning\":\r\n            if features.is_specialized:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"تخصصی\")\r\n            if features.complexity in [QueryComplexity.COMPLEX, QueryComplexity.VERY_COMPLEX]:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] -= 10  # کندتر اما دقیق‌تر\r\n                reasoning_parts.append(\"پیچیدگی بالا\")\r\n            if features.confidence_needed > 0.9:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"نیاز به دقت بالا\")\r\n            if features.urgency == QueryUrgency.BATCH:\r\n                scores[\"speed\"] += 10  # زمان مهم نیست\r\n            if features.requires_reasoning:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"استدلال پیچیده\")\r\n        \r\n        # LoRA برای تطبیق سریع\r\n        elif method == \"LoRA\":\r\n            if features.is_specialized and features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"تخصصی متوسط\")\r\n            if features.domain in [\"structural\", \"mep\"]:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(f\"حوزه {features.domain}\")\r\n            if features.requires_calculation and features.is_specialized:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"محاسبه تخصصی\")\r\n        \r\n        # Prompt Engineering برای سرعت\r\n        elif method == \"Prompt Engineering\":\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"نیاز به سرعت\")\r\n            if features.complexity == QueryComplexity.SIMPLE:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پرسش ساده\")\r\n            if not features.is_specialized:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"عمومی\")\r\n            if not features.requires_reasoning:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"بدون استدلال پیچیده\")\r\n        \r\n        # PEFT برای کارآیی\r\n        elif method == \"PEFT\":\r\n            if features.is_specialized and features.confidence_needed > 0.8:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"تخصصی با دقت\")\r\n            if features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"پیچیدگی متوسط\")\r\n            if features.domain == \"mep\":\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"مناسب MEP\")\r\n        \r\n        # محاسبه امتیاز نهایی\r\n        speed_score = min(scores[\"speed\"], 100)\r\n        accuracy_score = min(scores[\"accuracy\"], 100)\r\n        cost_score = min(scores[\"cost\"], 100)\r\n        \r\n        # امتیاز وزن‌دار\r\n        final_score = (\r\n            speed_score * self.weights[\"speed\"] +\r\n            accuracy_score * self.weights[\"accuracy\"] +\r\n            cost_score * self.weights[\"cost\"]\r\n        )\r\n        \r\n        # اضافه کردن تاریخچه عملکرد (با وزن کمتر)\r\n        perf = self.method_performance[method]\r\n        performance_factor = 0.7 + (perf[\"success_rate\"] * 0.3)  # 70% base + 30% history\r\n        final_score *= performance_factor\r\n        \r\n        reasoning = f\"{method}: \" + \", \".join(reasoning_parts) if reasoning_parts else f\"{method}: امتیاز پایه\"\r\n        \r\n        return MethodScore(\r\n            method=method,\r\n            score=final_score,\r\n            speed_score=speed_score,\r\n            accuracy_score=accuracy_score,\r\n            cost_score=cost_score,\r\n            reasoning=reasoning\r\n        )\r\n    \r\n    def explain_decision(\r\n        self,\r\n        query: str,\r\n        features: QueryFeatures,\r\n        selected_method: str,\r\n        score: MethodScore,\r\n        all_scores: Optional[List[MethodScore]] = None\r\n    ) -> Dict:\r\n        \"\"\"\r\n        توضیح دلیل انتخاب روش\r\n        \r\n        Returns:\r\n            توضیحات کامل تصمیم\r\n        \"\"\"\r\n        \r\n        explanation = {\r\n            \"query\": query,\r\n            \"selected_method\": selected_method,\r\n            \"reasoning\": score.reasoning,\r\n            \"features\": {\r\n                \"complexity\": features.complexity.value,\r\n                \"urgency\": features.urgency.value,\r\n                \"domain\": features.domain,\r\n                \"requires_knowledge\": features.requires_knowledge,\r\n                \"requires_calculation\": features.requires_calculation,\r\n                \"is_specialized\": features.is_specialized,\r\n                \"confidence_needed\": f\"{features.confidence_needed:.0%}\"\r\n            },\r\n            \"scores\": {\r\n                \"final\": f\"{score.score:.1f}\",\r\n                \"speed\": f\"{score.speed_score:.1f}\",\r\n                \"accuracy\": f\"{score.accuracy_score:.1f}\",\r\n                \"cost\": f\"{score.cost_score:.1f}\"\r\n            }\r\n        }\r\n        \r\n        if all_scores:\r\n            explanation[\"alternatives\"] = [\r\n                {\r\n                    \"method\": s.method,\r\n                    \"score\": f\"{s.score:.1f}\",\r\n                    \"reasoning\": s.reasoning\r\n                }\r\n                for s in all_scores[:3]  # تاپ 3\r\n            ]\r\n        \r\n        return explanation\r\n    \r\n    def update_performance(self, method: str, success: bool, execution_time: float):\r\n        \"\"\"به‌روزرسانی آمار عملکرد برای یادگیری\"\"\"\r\n        \r\n        if method not in self.method_performance:\r\n            return\r\n        \r\n        perf = self.method_performance[method]\r\n        \r\n        # به‌روزرسانی نرخ موفقیت (با میانگین متحرک)\r\n        alpha = 0.1  # ضریب یادگیری\r\n        perf[\"success_rate\"] = (\r\n            (1 - alpha) * perf[\"success_rate\"] +\r\n            alpha * (1.0 if success else 0.0)\r\n        )\r\n        \r\n        # به‌روزرسانی زمان متوسط\r\n        perf[\"avg_time\"] = (\r\n            (1 - alpha) * perf[\"avg_time\"] +\r\n            alpha * execution_time\r\n        )\r\n    \r\n    def get_performance_stats(self) -> Dict:\r\n        \"\"\"دریافت آمار عملکرد همه روش‌ها\"\"\"\r\n        return {\r\n            method: {\r\n                \"success_rate\": f\"{stats['success_rate']:.1%}\",\r\n                \"avg_time\": f\"{stats['avg_time']:.2f}s\"\r\n            }\r\n            for method, stats in self.method_performance.items()\r\n        }\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:03:37.138Z",
    "fileName": "cad3d\\super_ai\\meta_controller.py",
    "content": "\"\"\"\r\nMeta-Controller for Intelligent AI Method Selection\r\n\r\nتحلیل‌گر هوشمند پرسش و انتخاب بهترین روش AI\r\nبر اساس ویژگی‌های ورودی، تخصصی بودن، نیاز به سرعت/دقت\r\n\"\"\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom enum import Enum\r\nimport re\r\n\r\n\r\nclass QueryComplexity(Enum):\r\n    \"\"\"پیچیدگی پرسش\"\"\"\r\n    SIMPLE = \"simple\"           # ساده - محاسبه مستقیم\r\n    MODERATE = \"moderate\"       # متوسط - نیاز به استدلال\r\n    COMPLEX = \"complex\"         # پیچیده - تحلیل چندمرحله‌ای\r\n    VERY_COMPLEX = \"very_complex\"  # بسیار پیچیده - نیاز به تخصص\r\n\r\n\r\nclass QueryUrgency(Enum):\r\n    \"\"\"فوریت پاسخ\"\"\"\r\n    REALTIME = \"realtime\"       # لحظه‌ای < 100ms\r\n    FAST = \"fast\"               # سریع < 1s\r\n    NORMAL = \"normal\"           # عادی < 5s\r\n    BATCH = \"batch\"             # دسته‌ای - بدون محدودیت\r\n\r\n\r\n@dataclass\r\nclass QueryFeatures:\r\n    \"\"\"ویژگی‌های استخراج‌شده از پرسش\"\"\"\r\n    length: int                          # طول متن\r\n    has_numbers: bool                    # شامل اعداد\r\n    has_technical_terms: bool            # اصطلاحات تخصصی\r\n    requires_calculation: bool           # نیاز به محاسبه\r\n    requires_knowledge: bool             # نیاز به دانش پایه\r\n    requires_reasoning: bool             # نیاز به استدلال\r\n    is_specialized: bool                 # تخصصی (معماری، سازه، تاسیسات)\r\n    complexity: QueryComplexity          # پیچیدگی\r\n    urgency: QueryUrgency               # فوریت\r\n    domain: Optional[str]               # حوزه (architecture, structural, MEP, etc.)\r\n    confidence_needed: float            # دقت موردنیاز (0-1)\r\n\r\n\r\n@dataclass\r\nclass MethodScore:\r\n    \"\"\"امتیاز هر روش برای پرسش\"\"\"\r\n    method: str\r\n    score: float                        # امتیاز کلی (0-100)\r\n    speed_score: float                  # امتیاز سرعت\r\n    accuracy_score: float               # امتیاز دقت\r\n    cost_score: float                   # امتیاز هزینه\r\n    reasoning: str                      # دلیل انتخاب\r\n\r\n\r\nclass MetaController:\r\n    \"\"\"\r\n    کنترلر هوشمند انتخاب روش AI\r\n    \r\n    تحلیل ویژگی‌های پرسش:\r\n    - طول و پیچیدگی\r\n    - تخصصی بودن\r\n    - نیاز به داده به‌روز\r\n    - سرعت پاسخ\r\n    - حساسیت به خطا\r\n    \r\n    تصمیم‌گیری بر اساس:\r\n    - امتیازدهی چندمعیاره\r\n    - قوانین خبره\r\n    - تاریخچه عملکرد\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # الگوهای تشخیص\r\n        self.number_pattern = re.compile(r'\\d+\\.?\\d*')\r\n        self.calculation_keywords = [\r\n            \"محاسبه\", \"حساب\", \"چقدر\", \"چند\", \"جمع\", \"تفریق\", \"ضرب\", \"تقسیم\",\r\n            \"calculate\", \"compute\", \"how much\", \"how many\", \"sum\", \"total\"\r\n        ]\r\n        self.technical_terms = [\r\n            \"معماری\", \"سازه\", \"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"بتن\", \"فولاد\",\r\n            \"architecture\", \"structural\", \"mep\", \"hvac\", \"concrete\", \"steel\", \"beam\", \"column\"\r\n        ]\r\n        self.knowledge_keywords = [\r\n            \"استاندارد\", \"ضابطه\", \"مبحث\", \"قانون\", \"آیین‌نامه\", \"تعریف\", \"چیست\",\r\n            \"بهینه\", \"طراحی\", \"ساختار\", \"ساختمان\", \"سازه‌ای\",\r\n            \"standard\", \"code\", \"regulation\", \"definition\", \"what is\", \"explain\",\r\n            \"design\", \"structure\", \"building\", \"structural\", \"optimize\", \"optimization\"\r\n        ]\r\n        self.reasoning_keywords = [\r\n            \"تحلیل\", \"بررسی\", \"مقایسه\", \"ارزیابی\", \"بهینه\", \"پیشنهاد\", \"چرا\",\r\n            \"analyze\", \"compare\", \"evaluate\", \"optimize\", \"suggest\", \"why\", \"because\"\r\n        ]\r\n        \r\n        # وزن‌ها برای تصمیم‌گیری (قابل تنظیم)\r\n        self.weights = {\r\n            \"speed\": 0.3,      # اهمیت سرعت\r\n            \"accuracy\": 0.4,   # اهمیت دقت\r\n            \"cost\": 0.3        # اهمیت هزینه\r\n        }\r\n        \r\n        # آمار عملکرد روش‌ها (برای یادگیری)\r\n        self.method_performance = {\r\n            \"RAG\": {\"success_rate\": 0.95, \"avg_time\": 0.5},\r\n            \"Fine-Tuning\": {\"success_rate\": 0.98, \"avg_time\": 1.2},\r\n            \"LoRA\": {\"success_rate\": 0.92, \"avg_time\": 0.8},\r\n            \"Prompt Engineering\": {\"success_rate\": 0.85, \"avg_time\": 0.3},\r\n            \"PEFT\": {\"success_rate\": 0.90, \"avg_time\": 0.6}\r\n        }\r\n    \r\n    def analyze_query(self, query: str, task_type: Optional[str] = None) -> QueryFeatures:\r\n        \"\"\"\r\n        تحلیل کامل پرسش و استخراج ویژگی‌ها\r\n        \r\n        Args:\r\n            query: متن پرسش\r\n            task_type: نوع وظیفه (اختیاری)\r\n        \r\n        Returns:\r\n            ویژگی‌های استخراج‌شده\r\n        \"\"\"\r\n        query_lower = query.lower()\r\n        \r\n        # طول و اعداد\r\n        length = len(query)\r\n        has_numbers = bool(self.number_pattern.search(query))\r\n        \r\n        # تشخیص نیازها\r\n        requires_calculation = any(kw in query_lower for kw in self.calculation_keywords)\r\n        requires_knowledge = any(kw in query_lower for kw in self.knowledge_keywords)\r\n        requires_reasoning = any(kw in query_lower for kw in self.reasoning_keywords)\r\n        \r\n        # تخصصی بودن\r\n        has_technical_terms = any(term in query_lower for term in self.technical_terms)\r\n        is_specialized = has_technical_terms or (task_type and task_type in [\r\n            \"CAD_ANALYSIS\", \"STRUCTURAL_CALCULATION\", \"MEP_OPTIMIZATION\"\r\n        ])\r\n        \r\n        # تشخیص حوزه\r\n        domain = self._detect_domain(query_lower)\r\n        \r\n        # پیچیدگی\r\n        complexity = self._assess_complexity(\r\n            length, has_numbers, requires_calculation,\r\n            requires_knowledge, requires_reasoning, is_specialized\r\n        )\r\n        \r\n        # فوریت (پیش‌فرض بر اساس پیچیدگی)\r\n        urgency = self._assess_urgency(complexity, requires_calculation)\r\n        \r\n        # دقت موردنیاز\r\n        confidence_needed = self._assess_confidence_requirement(\r\n            requires_calculation, is_specialized, has_numbers\r\n        )\r\n        \r\n        return QueryFeatures(\r\n            length=length,\r\n            has_numbers=has_numbers,\r\n            has_technical_terms=has_technical_terms,\r\n            requires_calculation=requires_calculation,\r\n            requires_knowledge=requires_knowledge,\r\n            requires_reasoning=requires_reasoning,\r\n            is_specialized=is_specialized,\r\n            complexity=complexity,\r\n            urgency=urgency,\r\n            domain=domain,\r\n            confidence_needed=confidence_needed\r\n        )\r\n    \r\n    def _detect_domain(self, query_lower: str) -> Optional[str]:\r\n        \"\"\"تشخیص حوزه تخصصی\"\"\"\r\n        domains = {\r\n            \"architecture\": [\"معماری\", \"طراحی\", \"اتاق\", \"خانه\", \"ساختمان\", \"فضا\", \"architecture\", \"design\", \"room\", \"building\"],\r\n            \"structural\": [\"سازه\", \"تیر\", \"ستون\", \"بتن\", \"فولاد\", \"structural\", \"beam\", \"column\", \"concrete\", \"steel\"],\r\n            \"mep\": [\"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"mep\", \"hvac\", \"electrical\", \"plumbing\"],\r\n            \"calculation\": [\"محاسبه\", \"حساب\", \"عدد\", \"calculate\", \"compute\", \"number\"],\r\n            \"general\": []\r\n        }\r\n        \r\n        for domain, keywords in domains.items():\r\n            if any(kw in query_lower for kw in keywords):\r\n                return domain\r\n        \r\n        return \"general\"\r\n    \r\n    def _assess_complexity(\r\n        self,\r\n        length: int,\r\n        has_numbers: bool,\r\n        requires_calculation: bool,\r\n        requires_knowledge: bool,\r\n        requires_reasoning: bool,\r\n        is_specialized: bool\r\n    ) -> QueryComplexity:\r\n        \"\"\"ارزیابی پیچیدگی پرسش\"\"\"\r\n        \r\n        score = 0\r\n        \r\n        # طول\r\n        if length > 200: score += 2\r\n        elif length > 100: score += 1\r\n        \r\n        # نیازها\r\n        if requires_calculation: score += 1\r\n        if requires_knowledge: score += 1\r\n        if requires_reasoning: score += 2\r\n        if is_specialized: score += 2\r\n        if has_numbers and requires_calculation: score += 1\r\n        \r\n        if score >= 6:\r\n            return QueryComplexity.VERY_COMPLEX\r\n        elif score >= 4:\r\n            return QueryComplexity.COMPLEX\r\n        elif score >= 2:\r\n            return QueryComplexity.MODERATE\r\n        else:\r\n            return QueryComplexity.SIMPLE\r\n    \r\n    def _assess_urgency(self, complexity: QueryComplexity, requires_calculation: bool) -> QueryUrgency:\r\n        \"\"\"ارزیابی فوریت پاسخ\"\"\"\r\n        \r\n        # محاسبات ساده نیاز به سرعت بالا دارند\r\n        if requires_calculation and complexity == QueryComplexity.SIMPLE:\r\n            return QueryUrgency.FAST\r\n        \r\n        # پرسش‌های پیچیده می‌توانند کندتر باشند\r\n        if complexity == QueryComplexity.VERY_COMPLEX:\r\n            return QueryUrgency.BATCH\r\n        elif complexity == QueryComplexity.COMPLEX:\r\n            return QueryUrgency.NORMAL\r\n        else:\r\n            return QueryUrgency.FAST\r\n    \r\n    def _assess_confidence_requirement(\r\n        self,\r\n        requires_calculation: bool,\r\n        is_specialized: bool,\r\n        has_numbers: bool\r\n    ) -> float:\r\n        \"\"\"ارزیابی سطح دقت موردنیاز (0-1)\"\"\"\r\n        \r\n        confidence = 0.7  # پایه\r\n        \r\n        if requires_calculation: confidence += 0.15\r\n        if is_specialized: confidence += 0.10\r\n        if has_numbers: confidence += 0.05\r\n        \r\n        return min(confidence, 1.0)\r\n    \r\n    def select_best_method(\r\n        self,\r\n        features: QueryFeatures,\r\n        available_methods: Optional[List[str]] = None\r\n    ) -> Tuple[str, MethodScore]:\r\n        \"\"\"\r\n        انتخاب بهترین روش بر اساس ویژگی‌های پرسش\r\n        \r\n        Args:\r\n            features: ویژگی‌های پرسش\r\n            available_methods: روش‌های در دسترس (همه اگر None)\r\n        \r\n        Returns:\r\n            (روش انتخاب‌شده, امتیازات)\r\n        \"\"\"\r\n        \r\n        if available_methods is None:\r\n            available_methods = [\"RAG\", \"Fine-Tuning\", \"LoRA\", \"Prompt Engineering\", \"PEFT\"]\r\n        \r\n        # محاسبه امتیاز هر روش\r\n        scores = []\r\n        \r\n        for method in available_methods:\r\n            score = self._score_method(method, features)\r\n            scores.append(score)\r\n        \r\n        # مرتب‌سازی بر اساس امتیاز کلی\r\n        scores.sort(key=lambda x: x.score, reverse=True)\r\n        \r\n        best_method = scores[0].method\r\n        best_score = scores[0]\r\n        \r\n        return best_method, best_score\r\n    \r\n    def _score_method(self, method: str, features: QueryFeatures) -> MethodScore:\r\n        \"\"\"محاسبه امتیاز یک روش برای پرسش\"\"\"\r\n        \r\n        # امتیازات پایه هر روش\r\n        base_scores = {\r\n            \"RAG\": {\r\n                \"speed\": 85,      # سریع\r\n                \"accuracy\": 90,   # دقیق (با منابع)\r\n                \"cost\": 90        # ارزان\r\n            },\r\n            \"Fine-Tuning\": {\r\n                \"speed\": 70,      # کندتر\r\n                \"accuracy\": 95,   # بسیار دقیق\r\n                \"cost\": 40        # گران\r\n            },\r\n            \"LoRA\": {\r\n                \"speed\": 75,      # متوسط\r\n                \"accuracy\": 88,   # خوب\r\n                \"cost\": 70        # متوسط\r\n            },\r\n            \"Prompt Engineering\": {\r\n                \"speed\": 95,      # خیلی سریع\r\n                \"accuracy\": 75,   # متوسط\r\n                \"cost\": 95        # خیلی ارزان\r\n            },\r\n            \"PEFT\": {\r\n                \"speed\": 80,      # سریع\r\n                \"accuracy\": 85,   # خوب\r\n                \"cost\": 80        # ارزان\r\n            }\r\n        }\r\n        \r\n        scores = base_scores[method].copy()\r\n        reasoning_parts = []\r\n        \r\n        # تنظیمات بر اساس ویژگی‌های پرسش\r\n        \r\n        # RAG برای دانش و محاسبات عالی است\r\n        if method == \"RAG\":\r\n            if features.requires_knowledge:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"نیاز به دانش پایه\")\r\n            if features.requires_calculation:\r\n                scores[\"accuracy\"] += 3\r\n                reasoning_parts.append(\"محاسبه با منابع\")\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پاسخ سریع\")\r\n        \r\n        # Fine-Tuning برای کارهای تخصصی پیچیده\r\n        elif method == \"Fine-Tuning\":\r\n            if features.is_specialized:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"تخصصی\")\r\n            if features.complexity in [QueryComplexity.COMPLEX, QueryComplexity.VERY_COMPLEX]:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] -= 10  # کندتر اما دقیق‌تر\r\n                reasoning_parts.append(\"پیچیدگی بالا\")\r\n            if features.confidence_needed > 0.9:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"نیاز به دقت بالا\")\r\n            if features.urgency == QueryUrgency.BATCH:\r\n                scores[\"speed\"] += 10  # زمان مهم نیست\r\n            if features.requires_reasoning:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"استدلال پیچیده\")\r\n        \r\n        # LoRA برای تطبیق سریع\r\n        elif method == \"LoRA\":\r\n            if features.is_specialized and features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"تخصصی متوسط\")\r\n            if features.domain in [\"structural\", \"mep\"]:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(f\"حوزه {features.domain}\")\r\n            if features.requires_calculation and features.is_specialized:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"محاسبه تخصصی\")\r\n        \r\n        # Prompt Engineering برای سرعت\r\n        elif method == \"Prompt Engineering\":\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"نیاز به سرعت\")\r\n            if features.complexity == QueryComplexity.SIMPLE:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پرسش ساده\")\r\n            if not features.is_specialized:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"عمومی\")\r\n            if not features.requires_reasoning:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"بدون استدلال پیچیده\")\r\n        \r\n        # PEFT برای کارآیی\r\n        elif method == \"PEFT\":\r\n            if features.is_specialized and features.confidence_needed > 0.8:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"تخصصی با دقت\")\r\n            if features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"پیچیدگی متوسط\")\r\n            if features.domain == \"mep\":\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"مناسب MEP\")\r\n        \r\n        # محاسبه امتیاز نهایی\r\n        speed_score = min(scores[\"speed\"], 100)\r\n        accuracy_score = min(scores[\"accuracy\"], 100)\r\n        cost_score = min(scores[\"cost\"], 100)\r\n        \r\n        # امتیاز وزن‌دار\r\n        final_score = (\r\n            speed_score * self.weights[\"speed\"] +\r\n            accuracy_score * self.weights[\"accuracy\"] +\r\n            cost_score * self.weights[\"cost\"]\r\n        )\r\n        \r\n        # اضافه کردن تاریخچه عملکرد (با وزن کمتر)\r\n        perf = self.method_performance[method]\r\n        performance_factor = 0.7 + (perf[\"success_rate\"] * 0.3)  # 70% base + 30% history\r\n        final_score *= performance_factor\r\n        \r\n        reasoning = f\"{method}: \" + \", \".join(reasoning_parts) if reasoning_parts else f\"{method}: امتیاز پایه\"\r\n        \r\n        return MethodScore(\r\n            method=method,\r\n            score=final_score,\r\n            speed_score=speed_score,\r\n            accuracy_score=accuracy_score,\r\n            cost_score=cost_score,\r\n            reasoning=reasoning\r\n        )\r\n    \r\n    def explain_decision(\r\n        self,\r\n        query: str,\r\n        features: QueryFeatures,\r\n        selected_method: str,\r\n        score: MethodScore,\r\n        all_scores: Optional[List[MethodScore]] = None\r\n    ) -> Dict:\r\n        \"\"\"\r\n        توضیح دلیل انتخاب روش\r\n        \r\n        Returns:\r\n            توضیحات کامل تصمیم\r\n        \"\"\"\r\n        \r\n        explanation = {\r\n            \"query\": query,\r\n            \"selected_method\": selected_method,\r\n            \"reasoning\": score.reasoning,\r\n            \"features\": {\r\n                \"complexity\": features.complexity.value,\r\n                \"urgency\": features.urgency.value,\r\n                \"domain\": features.domain,\r\n                \"requires_knowledge\": features.requires_knowledge,\r\n                \"requires_calculation\": features.requires_calculation,\r\n                \"is_specialized\": features.is_specialized,\r\n                \"confidence_needed\": f\"{features.confidence_needed:.0%}\"\r\n            },\r\n            \"scores\": {\r\n                \"final\": f\"{score.score:.1f}\",\r\n                \"speed\": f\"{score.speed_score:.1f}\",\r\n                \"accuracy\": f\"{score.accuracy_score:.1f}\",\r\n                \"cost\": f\"{score.cost_score:.1f}\"\r\n            }\r\n        }\r\n        \r\n        if all_scores:\r\n            explanation[\"alternatives\"] = [\r\n                {\r\n                    \"method\": s.method,\r\n                    \"score\": f\"{s.score:.1f}\",\r\n                    \"reasoning\": s.reasoning\r\n                }\r\n                for s in all_scores[:3]  # تاپ 3\r\n            ]\r\n        \r\n        return explanation\r\n    \r\n    def update_performance(self, method: str, success: bool, execution_time: float):\r\n        \"\"\"به‌روزرسانی آمار عملکرد برای یادگیری\"\"\"\r\n        \r\n        if method not in self.method_performance:\r\n            return\r\n        \r\n        perf = self.method_performance[method]\r\n        \r\n        # به‌روزرسانی نرخ موفقیت (با میانگین متحرک)\r\n        alpha = 0.1  # ضریب یادگیری\r\n        perf[\"success_rate\"] = (\r\n            (1 - alpha) * perf[\"success_rate\"] +\r\n            alpha * (1.0 if success else 0.0)\r\n        )\r\n        \r\n        # به‌روزرسانی زمان متوسط\r\n        perf[\"avg_time\"] = (\r\n            (1 - alpha) * perf[\"avg_time\"] +\r\n            alpha * execution_time\r\n        )\r\n    \r\n    def get_performance_stats(self) -> Dict:\r\n        \"\"\"دریافت آمار عملکرد همه روش‌ها\"\"\"\r\n        return {\r\n            method: {\r\n                \"success_rate\": f\"{stats['success_rate']:.1%}\",\r\n                \"avg_time\": f\"{stats['avg_time']:.2f}s\"\r\n            }\r\n            for method, stats in self.method_performance.items()\r\n        }\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:03:52.078Z",
    "fileName": "cad3d\\super_ai\\meta_controller.py",
    "content": "\"\"\"\r\nMeta-Controller for Intelligent AI Method Selection\r\n\r\nتحلیل‌گر هوشمند پرسش و انتخاب بهترین روش AI\r\nبر اساس ویژگی‌های ورودی، تخصصی بودن، نیاز به سرعت/دقت\r\n\"\"\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom enum import Enum\r\nimport re\r\n\r\n\r\nclass QueryComplexity(Enum):\r\n    \"\"\"پیچیدگی پرسش\"\"\"\r\n    SIMPLE = \"simple\"           # ساده - محاسبه مستقیم\r\n    MODERATE = \"moderate\"       # متوسط - نیاز به استدلال\r\n    COMPLEX = \"complex\"         # پیچیده - تحلیل چندمرحله‌ای\r\n    VERY_COMPLEX = \"very_complex\"  # بسیار پیچیده - نیاز به تخصص\r\n\r\n\r\nclass QueryUrgency(Enum):\r\n    \"\"\"فوریت پاسخ\"\"\"\r\n    REALTIME = \"realtime\"       # لحظه‌ای < 100ms\r\n    FAST = \"fast\"               # سریع < 1s\r\n    NORMAL = \"normal\"           # عادی < 5s\r\n    BATCH = \"batch\"             # دسته‌ای - بدون محدودیت\r\n\r\n\r\n@dataclass\r\nclass QueryFeatures:\r\n    \"\"\"ویژگی‌های استخراج‌شده از پرسش\"\"\"\r\n    length: int                          # طول متن\r\n    has_numbers: bool                    # شامل اعداد\r\n    has_technical_terms: bool            # اصطلاحات تخصصی\r\n    requires_calculation: bool           # نیاز به محاسبه\r\n    requires_knowledge: bool             # نیاز به دانش پایه\r\n    requires_reasoning: bool             # نیاز به استدلال\r\n    is_specialized: bool                 # تخصصی (معماری، سازه، تاسیسات)\r\n    complexity: QueryComplexity          # پیچیدگی\r\n    urgency: QueryUrgency               # فوریت\r\n    domain: Optional[str]               # حوزه (architecture, structural, MEP, etc.)\r\n    confidence_needed: float            # دقت موردنیاز (0-1)\r\n\r\n\r\n@dataclass\r\nclass MethodScore:\r\n    \"\"\"امتیاز هر روش برای پرسش\"\"\"\r\n    method: str\r\n    score: float                        # امتیاز کلی (0-100)\r\n    speed_score: float                  # امتیاز سرعت\r\n    accuracy_score: float               # امتیاز دقت\r\n    cost_score: float                   # امتیاز هزینه\r\n    reasoning: str                      # دلیل انتخاب\r\n\r\n\r\nclass MetaController:\r\n    \"\"\"\r\n    کنترلر هوشمند انتخاب روش AI\r\n    \r\n    تحلیل ویژگی‌های پرسش:\r\n    - طول و پیچیدگی\r\n    - تخصصی بودن\r\n    - نیاز به داده به‌روز\r\n    - سرعت پاسخ\r\n    - حساسیت به خطا\r\n    \r\n    تصمیم‌گیری بر اساس:\r\n    - امتیازدهی چندمعیاره\r\n    - قوانین خبره\r\n    - تاریخچه عملکرد\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # الگوهای تشخیص\r\n        self.number_pattern = re.compile(r'\\d+\\.?\\d*')\r\n        self.calculation_keywords = [\r\n            \"محاسبه\", \"حساب\", \"چقدر\", \"چند\", \"جمع\", \"تفریق\", \"ضرب\", \"تقسیم\",\r\n            \"calculate\", \"compute\", \"how much\", \"how many\", \"sum\", \"total\"\r\n        ]\r\n        self.technical_terms = [\r\n            \"معماری\", \"سازه\", \"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"بتن\", \"فولاد\",\r\n            \"architecture\", \"structural\", \"mep\", \"hvac\", \"concrete\", \"steel\", \"beam\", \"column\"\r\n        ]\r\n        self.knowledge_keywords = [\r\n            \"استاندارد\", \"ضابطه\", \"مبحث\", \"قانون\", \"آیین‌نامه\", \"تعریف\", \"چیست\",\r\n            \"بهینه\", \"طراحی\", \"ساختار\", \"ساختمان\", \"سازه‌ای\",\r\n            \"standard\", \"code\", \"regulation\", \"definition\", \"what is\", \"explain\",\r\n            \"design\", \"structure\", \"building\", \"structural\", \"optimize\", \"optimization\"\r\n        ]\r\n        self.reasoning_keywords = [\r\n            \"تحلیل\", \"بررسی\", \"مقایسه\", \"ارزیابی\", \"بهینه\", \"پیشنهاد\", \"چرا\",\r\n            \"analyze\", \"compare\", \"evaluate\", \"optimize\", \"suggest\", \"why\", \"because\"\r\n        ]\r\n        \r\n        # وزن‌ها برای تصمیم‌گیری (قابل تنظیم)\r\n        self.weights = {\r\n            \"speed\": 0.3,      # اهمیت سرعت\r\n            \"accuracy\": 0.4,   # اهمیت دقت\r\n            \"cost\": 0.3        # اهمیت هزینه\r\n        }\r\n        \r\n        # آمار عملکرد روش‌ها (برای یادگیری)\r\n        self.method_performance = {\r\n            \"RAG\": {\"success_rate\": 0.95, \"avg_time\": 0.5},\r\n            \"Fine-Tuning\": {\"success_rate\": 0.98, \"avg_time\": 1.2},\r\n            \"LoRA\": {\"success_rate\": 0.92, \"avg_time\": 0.8},\r\n            \"Prompt Engineering\": {\"success_rate\": 0.85, \"avg_time\": 0.3},\r\n            \"PEFT\": {\"success_rate\": 0.90, \"avg_time\": 0.6}\r\n        }\r\n    \r\n    def analyze_query(self, query: str, task_type: Optional[str] = None) -> QueryFeatures:\r\n        \"\"\"\r\n        تحلیل کامل پرسش و استخراج ویژگی‌ها\r\n        \r\n        Args:\r\n            query: متن پرسش\r\n            task_type: نوع وظیفه (اختیاری)\r\n        \r\n        Returns:\r\n            ویژگی‌های استخراج‌شده\r\n        \"\"\"\r\n        query_lower = query.lower()\r\n        \r\n        # طول و اعداد\r\n        length = len(query)\r\n        has_numbers = bool(self.number_pattern.search(query))\r\n        \r\n        # تشخیص نیازها\r\n        requires_calculation = any(kw in query_lower for kw in self.calculation_keywords)\r\n        requires_knowledge = any(kw in query_lower for kw in self.knowledge_keywords)\r\n        requires_reasoning = any(kw in query_lower for kw in self.reasoning_keywords)\r\n        \r\n        # تخصصی بودن\r\n        has_technical_terms = any(term in query_lower for term in self.technical_terms)\r\n        is_specialized = has_technical_terms or (task_type and task_type in [\r\n            \"CAD_ANALYSIS\", \"STRUCTURAL_CALCULATION\", \"MEP_OPTIMIZATION\"\r\n        ])\r\n        \r\n        # تشخیص حوزه\r\n        domain = self._detect_domain(query_lower)\r\n        \r\n        # پیچیدگی\r\n        complexity = self._assess_complexity(\r\n            length, has_numbers, requires_calculation,\r\n            requires_knowledge, requires_reasoning, is_specialized\r\n        )\r\n        \r\n        # فوریت (پیش‌فرض بر اساس پیچیدگی)\r\n        urgency = self._assess_urgency(complexity, requires_calculation)\r\n        \r\n        # دقت موردنیاز\r\n        confidence_needed = self._assess_confidence_requirement(\r\n            requires_calculation, is_specialized, has_numbers\r\n        )\r\n        \r\n        return QueryFeatures(\r\n            length=length,\r\n            has_numbers=has_numbers,\r\n            has_technical_terms=has_technical_terms,\r\n            requires_calculation=requires_calculation,\r\n            requires_knowledge=requires_knowledge,\r\n            requires_reasoning=requires_reasoning,\r\n            is_specialized=is_specialized,\r\n            complexity=complexity,\r\n            urgency=urgency,\r\n            domain=domain,\r\n            confidence_needed=confidence_needed\r\n        )\r\n    \r\n    def _detect_domain(self, query_lower: str) -> Optional[str]:\r\n        \"\"\"تشخیص حوزه تخصصی\"\"\"\r\n        domains = {\r\n            \"structural\": [\"سازه\", \"تیر\", \"ستون\", \"بتن\", \"فولاد\", \"ساختار سازه\", \"structural\", \"beam\", \"column\", \"concrete\", \"steel\"],\r\n            \"mep\": [\"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"فاضلاب\", \"ظرفیت لوله\", \"mep\", \"hvac\", \"electrical\", \"plumbing\", \"pipe\", \"drainage\"],\r\n            \"calculation\": [\"محاسبه\", \"حساب\", \"عدد\", \"calculate\", \"compute\", \"number\"],\r\n            \"architecture\": [\"معماری\", \"طراحی\", \"اتاق\", \"خانه\", \"ساختمان\", \"فضا\", \"چیدمان\", \"architecture\", \"design\", \"room\", \"building\", \"layout\"],\r\n            \"general\": []\r\n        }\r\n        \r\n        for domain, keywords in domains.items():\r\n            if any(kw in query_lower for kw in keywords):\r\n                return domain\r\n        \r\n        return \"general\"\r\n    \r\n    def _assess_complexity(\r\n        self,\r\n        length: int,\r\n        has_numbers: bool,\r\n        requires_calculation: bool,\r\n        requires_knowledge: bool,\r\n        requires_reasoning: bool,\r\n        is_specialized: bool\r\n    ) -> QueryComplexity:\r\n        \"\"\"ارزیابی پیچیدگی پرسش\"\"\"\r\n        \r\n        score = 0\r\n        \r\n        # طول\r\n        if length > 200: score += 2\r\n        elif length > 100: score += 1\r\n        \r\n        # نیازها\r\n        if requires_calculation: score += 1\r\n        if requires_knowledge: score += 1\r\n        if requires_reasoning: score += 2\r\n        if is_specialized: score += 2\r\n        if has_numbers and requires_calculation: score += 1\r\n        \r\n        if score >= 6:\r\n            return QueryComplexity.VERY_COMPLEX\r\n        elif score >= 4:\r\n            return QueryComplexity.COMPLEX\r\n        elif score >= 2:\r\n            return QueryComplexity.MODERATE\r\n        else:\r\n            return QueryComplexity.SIMPLE\r\n    \r\n    def _assess_urgency(self, complexity: QueryComplexity, requires_calculation: bool) -> QueryUrgency:\r\n        \"\"\"ارزیابی فوریت پاسخ\"\"\"\r\n        \r\n        # محاسبات ساده نیاز به سرعت بالا دارند\r\n        if requires_calculation and complexity == QueryComplexity.SIMPLE:\r\n            return QueryUrgency.FAST\r\n        \r\n        # پرسش‌های پیچیده می‌توانند کندتر باشند\r\n        if complexity == QueryComplexity.VERY_COMPLEX:\r\n            return QueryUrgency.BATCH\r\n        elif complexity == QueryComplexity.COMPLEX:\r\n            return QueryUrgency.NORMAL\r\n        else:\r\n            return QueryUrgency.FAST\r\n    \r\n    def _assess_confidence_requirement(\r\n        self,\r\n        requires_calculation: bool,\r\n        is_specialized: bool,\r\n        has_numbers: bool\r\n    ) -> float:\r\n        \"\"\"ارزیابی سطح دقت موردنیاز (0-1)\"\"\"\r\n        \r\n        confidence = 0.7  # پایه\r\n        \r\n        if requires_calculation: confidence += 0.15\r\n        if is_specialized: confidence += 0.10\r\n        if has_numbers: confidence += 0.05\r\n        \r\n        return min(confidence, 1.0)\r\n    \r\n    def select_best_method(\r\n        self,\r\n        features: QueryFeatures,\r\n        available_methods: Optional[List[str]] = None\r\n    ) -> Tuple[str, MethodScore]:\r\n        \"\"\"\r\n        انتخاب بهترین روش بر اساس ویژگی‌های پرسش\r\n        \r\n        Args:\r\n            features: ویژگی‌های پرسش\r\n            available_methods: روش‌های در دسترس (همه اگر None)\r\n        \r\n        Returns:\r\n            (روش انتخاب‌شده, امتیازات)\r\n        \"\"\"\r\n        \r\n        if available_methods is None:\r\n            available_methods = [\"RAG\", \"Fine-Tuning\", \"LoRA\", \"Prompt Engineering\", \"PEFT\"]\r\n        \r\n        # محاسبه امتیاز هر روش\r\n        scores = []\r\n        \r\n        for method in available_methods:\r\n            score = self._score_method(method, features)\r\n            scores.append(score)\r\n        \r\n        # مرتب‌سازی بر اساس امتیاز کلی\r\n        scores.sort(key=lambda x: x.score, reverse=True)\r\n        \r\n        best_method = scores[0].method\r\n        best_score = scores[0]\r\n        \r\n        return best_method, best_score\r\n    \r\n    def _score_method(self, method: str, features: QueryFeatures) -> MethodScore:\r\n        \"\"\"محاسبه امتیاز یک روش برای پرسش\"\"\"\r\n        \r\n        # امتیازات پایه هر روش\r\n        base_scores = {\r\n            \"RAG\": {\r\n                \"speed\": 85,      # سریع\r\n                \"accuracy\": 90,   # دقیق (با منابع)\r\n                \"cost\": 90        # ارزان\r\n            },\r\n            \"Fine-Tuning\": {\r\n                \"speed\": 70,      # کندتر\r\n                \"accuracy\": 95,   # بسیار دقیق\r\n                \"cost\": 40        # گران\r\n            },\r\n            \"LoRA\": {\r\n                \"speed\": 75,      # متوسط\r\n                \"accuracy\": 88,   # خوب\r\n                \"cost\": 70        # متوسط\r\n            },\r\n            \"Prompt Engineering\": {\r\n                \"speed\": 95,      # خیلی سریع\r\n                \"accuracy\": 75,   # متوسط\r\n                \"cost\": 95        # خیلی ارزان\r\n            },\r\n            \"PEFT\": {\r\n                \"speed\": 80,      # سریع\r\n                \"accuracy\": 85,   # خوب\r\n                \"cost\": 80        # ارزان\r\n            }\r\n        }\r\n        \r\n        scores = base_scores[method].copy()\r\n        reasoning_parts = []\r\n        \r\n        # تنظیمات بر اساس ویژگی‌های پرسش\r\n        \r\n        # RAG برای دانش و محاسبات عالی است\r\n        if method == \"RAG\":\r\n            if features.requires_knowledge:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"نیاز به دانش پایه\")\r\n            if features.requires_calculation:\r\n                scores[\"accuracy\"] += 3\r\n                reasoning_parts.append(\"محاسبه با منابع\")\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پاسخ سریع\")\r\n        \r\n        # Fine-Tuning برای کارهای تخصصی پیچیده\r\n        elif method == \"Fine-Tuning\":\r\n            if features.is_specialized:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"تخصصی\")\r\n            if features.complexity in [QueryComplexity.COMPLEX, QueryComplexity.VERY_COMPLEX]:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] -= 10  # کندتر اما دقیق‌تر\r\n                reasoning_parts.append(\"پیچیدگی بالا\")\r\n            if features.confidence_needed > 0.9:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"نیاز به دقت بالا\")\r\n            if features.urgency == QueryUrgency.BATCH:\r\n                scores[\"speed\"] += 10  # زمان مهم نیست\r\n            if features.requires_reasoning:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"استدلال پیچیده\")\r\n        \r\n        # LoRA برای تطبیق سریع\r\n        elif method == \"LoRA\":\r\n            if features.is_specialized and features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"تخصصی متوسط\")\r\n            if features.domain in [\"structural\", \"mep\"]:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(f\"حوزه {features.domain}\")\r\n            if features.requires_calculation and features.is_specialized:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"محاسبه تخصصی\")\r\n        \r\n        # Prompt Engineering برای سرعت\r\n        elif method == \"Prompt Engineering\":\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"نیاز به سرعت\")\r\n            if features.complexity == QueryComplexity.SIMPLE:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پرسش ساده\")\r\n            if not features.is_specialized:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"عمومی\")\r\n            if not features.requires_reasoning:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"بدون استدلال پیچیده\")\r\n        \r\n        # PEFT برای کارآیی\r\n        elif method == \"PEFT\":\r\n            if features.is_specialized and features.confidence_needed > 0.8:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"تخصصی با دقت\")\r\n            if features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"پیچیدگی متوسط\")\r\n            if features.domain == \"mep\":\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"مناسب MEP\")\r\n        \r\n        # محاسبه امتیاز نهایی\r\n        speed_score = min(scores[\"speed\"], 100)\r\n        accuracy_score = min(scores[\"accuracy\"], 100)\r\n        cost_score = min(scores[\"cost\"], 100)\r\n        \r\n        # امتیاز وزن‌دار\r\n        final_score = (\r\n            speed_score * self.weights[\"speed\"] +\r\n            accuracy_score * self.weights[\"accuracy\"] +\r\n            cost_score * self.weights[\"cost\"]\r\n        )\r\n        \r\n        # اضافه کردن تاریخچه عملکرد (با وزن کمتر)\r\n        perf = self.method_performance[method]\r\n        performance_factor = 0.7 + (perf[\"success_rate\"] * 0.3)  # 70% base + 30% history\r\n        final_score *= performance_factor\r\n        \r\n        reasoning = f\"{method}: \" + \", \".join(reasoning_parts) if reasoning_parts else f\"{method}: امتیاز پایه\"\r\n        \r\n        return MethodScore(\r\n            method=method,\r\n            score=final_score,\r\n            speed_score=speed_score,\r\n            accuracy_score=accuracy_score,\r\n            cost_score=cost_score,\r\n            reasoning=reasoning\r\n        )\r\n    \r\n    def explain_decision(\r\n        self,\r\n        query: str,\r\n        features: QueryFeatures,\r\n        selected_method: str,\r\n        score: MethodScore,\r\n        all_scores: Optional[List[MethodScore]] = None\r\n    ) -> Dict:\r\n        \"\"\"\r\n        توضیح دلیل انتخاب روش\r\n        \r\n        Returns:\r\n            توضیحات کامل تصمیم\r\n        \"\"\"\r\n        \r\n        explanation = {\r\n            \"query\": query,\r\n            \"selected_method\": selected_method,\r\n            \"reasoning\": score.reasoning,\r\n            \"features\": {\r\n                \"complexity\": features.complexity.value,\r\n                \"urgency\": features.urgency.value,\r\n                \"domain\": features.domain,\r\n                \"requires_knowledge\": features.requires_knowledge,\r\n                \"requires_calculation\": features.requires_calculation,\r\n                \"is_specialized\": features.is_specialized,\r\n                \"confidence_needed\": f\"{features.confidence_needed:.0%}\"\r\n            },\r\n            \"scores\": {\r\n                \"final\": f\"{score.score:.1f}\",\r\n                \"speed\": f\"{score.speed_score:.1f}\",\r\n                \"accuracy\": f\"{score.accuracy_score:.1f}\",\r\n                \"cost\": f\"{score.cost_score:.1f}\"\r\n            }\r\n        }\r\n        \r\n        if all_scores:\r\n            explanation[\"alternatives\"] = [\r\n                {\r\n                    \"method\": s.method,\r\n                    \"score\": f\"{s.score:.1f}\",\r\n                    \"reasoning\": s.reasoning\r\n                }\r\n                for s in all_scores[:3]  # تاپ 3\r\n            ]\r\n        \r\n        return explanation\r\n    \r\n    def update_performance(self, method: str, success: bool, execution_time: float):\r\n        \"\"\"به‌روزرسانی آمار عملکرد برای یادگیری\"\"\"\r\n        \r\n        if method not in self.method_performance:\r\n            return\r\n        \r\n        perf = self.method_performance[method]\r\n        \r\n        # به‌روزرسانی نرخ موفقیت (با میانگین متحرک)\r\n        alpha = 0.1  # ضریب یادگیری\r\n        perf[\"success_rate\"] = (\r\n            (1 - alpha) * perf[\"success_rate\"] +\r\n            alpha * (1.0 if success else 0.0)\r\n        )\r\n        \r\n        # به‌روزرسانی زمان متوسط\r\n        perf[\"avg_time\"] = (\r\n            (1 - alpha) * perf[\"avg_time\"] +\r\n            alpha * execution_time\r\n        )\r\n    \r\n    def get_performance_stats(self) -> Dict:\r\n        \"\"\"دریافت آمار عملکرد همه روش‌ها\"\"\"\r\n        return {\r\n            method: {\r\n                \"success_rate\": f\"{stats['success_rate']:.1%}\",\r\n                \"avg_time\": f\"{stats['avg_time']:.2f}s\"\r\n            }\r\n            for method, stats in self.method_performance.items()\r\n        }\r\n",
    "format": "py"
  },
  {
    "timestamp": "2025-11-21T23:04:14.014Z",
    "fileName": "cad3d\\super_ai\\meta_controller.py",
    "content": "\"\"\"\r\nMeta-Controller for Intelligent AI Method Selection\r\n\r\nتحلیل‌گر هوشمند پرسش و انتخاب بهترین روش AI\r\nبر اساس ویژگی‌های ورودی، تخصصی بودن، نیاز به سرعت/دقت\r\n\"\"\"\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom enum import Enum\r\nimport re\r\n\r\n\r\nclass QueryComplexity(Enum):\r\n    \"\"\"پیچیدگی پرسش\"\"\"\r\n    SIMPLE = \"simple\"           # ساده - محاسبه مستقیم\r\n    MODERATE = \"moderate\"       # متوسط - نیاز به استدلال\r\n    COMPLEX = \"complex\"         # پیچیده - تحلیل چندمرحله‌ای\r\n    VERY_COMPLEX = \"very_complex\"  # بسیار پیچیده - نیاز به تخصص\r\n\r\n\r\nclass QueryUrgency(Enum):\r\n    \"\"\"فوریت پاسخ\"\"\"\r\n    REALTIME = \"realtime\"       # لحظه‌ای < 100ms\r\n    FAST = \"fast\"               # سریع < 1s\r\n    NORMAL = \"normal\"           # عادی < 5s\r\n    BATCH = \"batch\"             # دسته‌ای - بدون محدودیت\r\n\r\n\r\n@dataclass\r\nclass QueryFeatures:\r\n    \"\"\"ویژگی‌های استخراج‌شده از پرسش\"\"\"\r\n    length: int                          # طول متن\r\n    has_numbers: bool                    # شامل اعداد\r\n    has_technical_terms: bool            # اصطلاحات تخصصی\r\n    requires_calculation: bool           # نیاز به محاسبه\r\n    requires_knowledge: bool             # نیاز به دانش پایه\r\n    requires_reasoning: bool             # نیاز به استدلال\r\n    is_specialized: bool                 # تخصصی (معماری، سازه، تاسیسات)\r\n    complexity: QueryComplexity          # پیچیدگی\r\n    urgency: QueryUrgency               # فوریت\r\n    domain: Optional[str]               # حوزه (architecture, structural, MEP, etc.)\r\n    confidence_needed: float            # دقت موردنیاز (0-1)\r\n\r\n\r\n@dataclass\r\nclass MethodScore:\r\n    \"\"\"امتیاز هر روش برای پرسش\"\"\"\r\n    method: str\r\n    score: float                        # امتیاز کلی (0-100)\r\n    speed_score: float                  # امتیاز سرعت\r\n    accuracy_score: float               # امتیاز دقت\r\n    cost_score: float                   # امتیاز هزینه\r\n    reasoning: str                      # دلیل انتخاب\r\n\r\n\r\nclass MetaController:\r\n    \"\"\"\r\n    کنترلر هوشمند انتخاب روش AI\r\n    \r\n    تحلیل ویژگی‌های پرسش:\r\n    - طول و پیچیدگی\r\n    - تخصصی بودن\r\n    - نیاز به داده به‌روز\r\n    - سرعت پاسخ\r\n    - حساسیت به خطا\r\n    \r\n    تصمیم‌گیری بر اساس:\r\n    - امتیازدهی چندمعیاره\r\n    - قوانین خبره\r\n    - تاریخچه عملکرد\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # الگوهای تشخیص\r\n        self.number_pattern = re.compile(r'\\d+\\.?\\d*')\r\n        self.calculation_keywords = [\r\n            \"محاسبه\", \"حساب\", \"چقدر\", \"چند\", \"جمع\", \"تفریق\", \"ضرب\", \"تقسیم\",\r\n            \"calculate\", \"compute\", \"how much\", \"how many\", \"sum\", \"total\"\r\n        ]\r\n        self.technical_terms = [\r\n            \"معماری\", \"سازه\", \"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"بتن\", \"فولاد\",\r\n            \"architecture\", \"structural\", \"mep\", \"hvac\", \"concrete\", \"steel\", \"beam\", \"column\"\r\n        ]\r\n        self.knowledge_keywords = [\r\n            \"استاندارد\", \"ضابطه\", \"مبحث\", \"قانون\", \"آیین‌نامه\", \"تعریف\", \"چیست\",\r\n            \"بهینه\", \"طراحی\", \"ساختار\", \"ساختمان\", \"سازه‌ای\",\r\n            \"standard\", \"code\", \"regulation\", \"definition\", \"what is\", \"explain\",\r\n            \"design\", \"structure\", \"building\", \"structural\", \"optimize\", \"optimization\"\r\n        ]\r\n        self.reasoning_keywords = [\r\n            \"تحلیل\", \"بررسی\", \"مقایسه\", \"ارزیابی\", \"بهینه\", \"پیشنهاد\", \"چرا\",\r\n            \"analyze\", \"compare\", \"evaluate\", \"optimize\", \"suggest\", \"why\", \"because\"\r\n        ]\r\n        \r\n        # وزن‌ها برای تصمیم‌گیری (قابل تنظیم)\r\n        self.weights = {\r\n            \"speed\": 0.3,      # اهمیت سرعت\r\n            \"accuracy\": 0.4,   # اهمیت دقت\r\n            \"cost\": 0.3        # اهمیت هزینه\r\n        }\r\n        \r\n        # آمار عملکرد روش‌ها (برای یادگیری)\r\n        self.method_performance = {\r\n            \"RAG\": {\"success_rate\": 0.95, \"avg_time\": 0.5},\r\n            \"Fine-Tuning\": {\"success_rate\": 0.98, \"avg_time\": 1.2},\r\n            \"LoRA\": {\"success_rate\": 0.92, \"avg_time\": 0.8},\r\n            \"Prompt Engineering\": {\"success_rate\": 0.85, \"avg_time\": 0.3},\r\n            \"PEFT\": {\"success_rate\": 0.90, \"avg_time\": 0.6}\r\n        }\r\n    \r\n    def analyze_query(self, query: str, task_type: Optional[str] = None) -> QueryFeatures:\r\n        \"\"\"\r\n        تحلیل کامل پرسش و استخراج ویژگی‌ها\r\n        \r\n        Args:\r\n            query: متن پرسش\r\n            task_type: نوع وظیفه (اختیاری)\r\n        \r\n        Returns:\r\n            ویژگی‌های استخراج‌شده\r\n        \"\"\"\r\n        query_lower = query.lower()\r\n        \r\n        # طول و اعداد\r\n        length = len(query)\r\n        has_numbers = bool(self.number_pattern.search(query))\r\n        \r\n        # تشخیص نیازها\r\n        requires_calculation = any(kw in query_lower for kw in self.calculation_keywords)\r\n        requires_knowledge = any(kw in query_lower for kw in self.knowledge_keywords)\r\n        requires_reasoning = any(kw in query_lower for kw in self.reasoning_keywords)\r\n        \r\n        # تخصصی بودن\r\n        has_technical_terms = any(term in query_lower for term in self.technical_terms)\r\n        is_specialized = has_technical_terms or (task_type and task_type in [\r\n            \"CAD_ANALYSIS\", \"STRUCTURAL_CALCULATION\", \"MEP_OPTIMIZATION\"\r\n        ])\r\n        \r\n        # تشخیص حوزه\r\n        domain = self._detect_domain(query_lower)\r\n        \r\n        # پیچیدگی\r\n        complexity = self._assess_complexity(\r\n            length, has_numbers, requires_calculation,\r\n            requires_knowledge, requires_reasoning, is_specialized\r\n        )\r\n        \r\n        # فوریت (پیش‌فرض بر اساس پیچیدگی)\r\n        urgency = self._assess_urgency(complexity, requires_calculation)\r\n        \r\n        # دقت موردنیاز\r\n        confidence_needed = self._assess_confidence_requirement(\r\n            requires_calculation, is_specialized, has_numbers\r\n        )\r\n        \r\n        return QueryFeatures(\r\n            length=length,\r\n            has_numbers=has_numbers,\r\n            has_technical_terms=has_technical_terms,\r\n            requires_calculation=requires_calculation,\r\n            requires_knowledge=requires_knowledge,\r\n            requires_reasoning=requires_reasoning,\r\n            is_specialized=is_specialized,\r\n            complexity=complexity,\r\n            urgency=urgency,\r\n            domain=domain,\r\n            confidence_needed=confidence_needed\r\n        )\r\n    \r\n    def _detect_domain(self, query_lower: str) -> Optional[str]:\r\n        \"\"\"تشخیص حوزه تخصصی\"\"\"\r\n        domains = {\r\n            \"structural\": [\"سازه\", \"تیر\", \"ستون\", \"بتن\", \"فولاد\", \"ساختار سازه\", \"structural\", \"beam\", \"column\", \"concrete\", \"steel\"],\r\n            \"mep\": [\"تاسیسات\", \"برق\", \"لوله‌کشی\", \"تهویه\", \"فاضلاب\", \"ظرفیت لوله\", \"mep\", \"hvac\", \"electrical\", \"plumbing\", \"pipe\", \"drainage\"],\r\n            \"calculation\": [\"محاسبه\", \"حساب\", \"عدد\", \"calculate\", \"compute\", \"number\"],\r\n            \"architecture\": [\"معماری\", \"طراحی\", \"اتاق\", \"خانه\", \"ساختمان\", \"فضا\", \"چیدمان\", \"architecture\", \"design\", \"room\", \"building\", \"layout\"],\r\n            \"general\": []\r\n        }\r\n        \r\n        for domain, keywords in domains.items():\r\n            if any(kw in query_lower for kw in keywords):\r\n                return domain\r\n        \r\n        return \"general\"\r\n    \r\n    def _assess_complexity(\r\n        self,\r\n        length: int,\r\n        has_numbers: bool,\r\n        requires_calculation: bool,\r\n        requires_knowledge: bool,\r\n        requires_reasoning: bool,\r\n        is_specialized: bool\r\n    ) -> QueryComplexity:\r\n        \"\"\"ارزیابی پیچیدگی پرسش\"\"\"\r\n        \r\n        score = 0\r\n        \r\n        # طول\r\n        if length > 200: score += 2\r\n        elif length > 100: score += 1\r\n        \r\n        # نیازها\r\n        if requires_calculation: score += 1\r\n        if requires_knowledge: score += 1\r\n        if requires_reasoning: score += 2\r\n        if is_specialized: score += 2\r\n        if has_numbers and requires_calculation: score += 1\r\n        \r\n        if score >= 6:\r\n            return QueryComplexity.VERY_COMPLEX\r\n        elif score >= 4:\r\n            return QueryComplexity.COMPLEX\r\n        elif score >= 2:\r\n            return QueryComplexity.MODERATE\r\n        else:\r\n            return QueryComplexity.SIMPLE\r\n    \r\n    def _assess_urgency(self, complexity: QueryComplexity, requires_calculation: bool) -> QueryUrgency:\r\n        \"\"\"ارزیابی فوریت پاسخ\"\"\"\r\n        \r\n        # محاسبات ساده نیاز به سرعت بالا دارند\r\n        if requires_calculation and complexity == QueryComplexity.SIMPLE:\r\n            return QueryUrgency.FAST\r\n        \r\n        # پرسش‌های پیچیده می‌توانند کندتر باشند\r\n        if complexity == QueryComplexity.VERY_COMPLEX:\r\n            return QueryUrgency.BATCH\r\n        elif complexity == QueryComplexity.COMPLEX:\r\n            return QueryUrgency.NORMAL\r\n        else:\r\n            return QueryUrgency.FAST\r\n    \r\n    def _assess_confidence_requirement(\r\n        self,\r\n        requires_calculation: bool,\r\n        is_specialized: bool,\r\n        has_numbers: bool\r\n    ) -> float:\r\n        \"\"\"ارزیابی سطح دقت موردنیاز (0-1)\"\"\"\r\n        \r\n        confidence = 0.7  # پایه\r\n        \r\n        if requires_calculation: confidence += 0.15\r\n        if is_specialized: confidence += 0.10\r\n        if has_numbers: confidence += 0.05\r\n        \r\n        return min(confidence, 1.0)\r\n    \r\n    def select_best_method(\r\n        self,\r\n        features: QueryFeatures,\r\n        available_methods: Optional[List[str]] = None\r\n    ) -> Tuple[str, MethodScore]:\r\n        \"\"\"\r\n        انتخاب بهترین روش بر اساس ویژگی‌های پرسش\r\n        \r\n        Args:\r\n            features: ویژگی‌های پرسش\r\n            available_methods: روش‌های در دسترس (همه اگر None)\r\n        \r\n        Returns:\r\n            (روش انتخاب‌شده, امتیازات)\r\n        \"\"\"\r\n        \r\n        if available_methods is None:\r\n            available_methods = [\"RAG\", \"Fine-Tuning\", \"LoRA\", \"Prompt Engineering\", \"PEFT\"]\r\n        \r\n        # محاسبه امتیاز هر روش\r\n        scores = []\r\n        \r\n        for method in available_methods:\r\n            score = self._score_method(method, features)\r\n            scores.append(score)\r\n        \r\n        # مرتب‌سازی بر اساس امتیاز کلی\r\n        scores.sort(key=lambda x: x.score, reverse=True)\r\n        \r\n        best_method = scores[0].method\r\n        best_score = scores[0]\r\n        \r\n        return best_method, best_score\r\n    \r\n    def _score_method(self, method: str, features: QueryFeatures) -> MethodScore:\r\n        \"\"\"محاسبه امتیاز یک روش برای پرسش\"\"\"\r\n        \r\n        # امتیازات پایه هر روش\r\n        base_scores = {\r\n            \"RAG\": {\r\n                \"speed\": 85,      # سریع\r\n                \"accuracy\": 90,   # دقیق (با منابع)\r\n                \"cost\": 90        # ارزان\r\n            },\r\n            \"Fine-Tuning\": {\r\n                \"speed\": 70,      # کندتر\r\n                \"accuracy\": 95,   # بسیار دقیق\r\n                \"cost\": 40        # گران\r\n            },\r\n            \"LoRA\": {\r\n                \"speed\": 75,      # متوسط\r\n                \"accuracy\": 88,   # خوب\r\n                \"cost\": 70        # متوسط\r\n            },\r\n            \"Prompt Engineering\": {\r\n                \"speed\": 95,      # خیلی سریع\r\n                \"accuracy\": 75,   # متوسط\r\n                \"cost\": 95        # خیلی ارزان\r\n            },\r\n            \"PEFT\": {\r\n                \"speed\": 80,      # سریع\r\n                \"accuracy\": 85,   # خوب\r\n                \"cost\": 80        # ارزان\r\n            }\r\n        }\r\n        \r\n        scores = base_scores[method].copy()\r\n        reasoning_parts = []\r\n        \r\n        # تنظیمات بر اساس ویژگی‌های پرسش\r\n        \r\n        # RAG برای دانش و محاسبات عالی است\r\n        if method == \"RAG\":\r\n            if features.requires_knowledge:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"نیاز به دانش پایه\")\r\n            if features.requires_calculation:\r\n                scores[\"accuracy\"] += 3\r\n                reasoning_parts.append(\"محاسبه با منابع\")\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پاسخ سریع\")\r\n        \r\n        # Fine-Tuning برای کارهای تخصصی پیچیده\r\n        elif method == \"Fine-Tuning\":\r\n            if features.is_specialized:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"تخصصی\")\r\n            if features.complexity in [QueryComplexity.COMPLEX, QueryComplexity.VERY_COMPLEX]:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] -= 10  # کندتر اما دقیق‌تر\r\n                reasoning_parts.append(\"پیچیدگی بالا\")\r\n            if features.confidence_needed > 0.9:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"نیاز به دقت بالا\")\r\n            if features.urgency == QueryUrgency.BATCH:\r\n                scores[\"speed\"] += 10  # زمان مهم نیست\r\n            if features.requires_reasoning:\r\n                scores[\"accuracy\"] += 10\r\n                reasoning_parts.append(\"استدلال پیچیده\")\r\n        \r\n        # LoRA برای تطبیق سریع\r\n        elif method == \"LoRA\":\r\n            if features.is_specialized and features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"تخصصی متوسط\")\r\n            if features.domain in [\"structural\", \"mep\"]:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(f\"حوزه {features.domain}\")\r\n            if features.requires_calculation and features.is_specialized:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"محاسبه تخصصی\")\r\n        \r\n        # Prompt Engineering برای سرعت\r\n        elif method == \"Prompt Engineering\":\r\n            if features.urgency == QueryUrgency.FAST:\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"نیاز به سرعت\")\r\n            if features.complexity == QueryComplexity.SIMPLE:\r\n                scores[\"accuracy\"] += 15\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"پرسش ساده\")\r\n            if not features.is_specialized:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"عمومی\")\r\n            if not features.requires_reasoning:\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"بدون استدلال پیچیده\")\r\n        \r\n        # PEFT برای کارآیی\r\n        elif method == \"PEFT\":\r\n            if features.is_specialized and features.confidence_needed > 0.8:\r\n                scores[\"accuracy\"] += 10\r\n                scores[\"speed\"] += 5\r\n                reasoning_parts.append(\"تخصصی با دقت\")\r\n            if features.complexity == QueryComplexity.MODERATE:\r\n                scores[\"accuracy\"] += 8\r\n                reasoning_parts.append(\"پیچیدگی متوسط\")\r\n            if features.domain == \"mep\":\r\n                scores[\"accuracy\"] += 5\r\n                reasoning_parts.append(\"مناسب MEP\")\r\n        \r\n        # محاسبه امتیاز نهایی\r\n        speed_score = min(scores[\"speed\"], 100)\r\n        accuracy_score = min(scores[\"accuracy\"], 100)\r\n        cost_score = min(scores[\"cost\"], 100)\r\n        \r\n        # امتیاز وزن‌دار\r\n        final_score = (\r\n            speed_score * self.weights[\"speed\"] +\r\n            accuracy_score * self.weights[\"accuracy\"] +\r\n            cost_score * self.weights[\"cost\"]\r\n        )\r\n        \r\n        # اضافه کردن تاریخچه عملکرد (با وزن کمتر)\r\n        perf = self.method_performance[method]\r\n        performance_factor = 0.7 + (perf[\"success_rate\"] * 0.3)  # 70% base + 30% history\r\n        final_score *= performance_factor\r\n        \r\n        reasoning = f\"{method}: \" + \", \".join(reasoning_parts) if reasoning_parts else f\"{method}: امتیاز پایه\"\r\n        \r\n        return MethodScore(\r\n            method=method,\r\n            score=final_score,\r\n            speed_score=speed_score,\r\n            accuracy_score=accuracy_score,\r\n            cost_score=cost_score,\r\n            reasoning=reasoning\r\n        )\r\n    \r\n    def explain_decision(\r\n        self,\r\n        query: str,\r\n        features: QueryFeatures,\r\n        selected_method: str,\r\n        score: MethodScore,\r\n        all_scores: Optional[List[MethodScore]] = None\r\n    ) -> Dict:\r\n        \"\"\"\r\n        توضیح دلیل انتخاب روش\r\n        \r\n        Returns:\r\n            توضیحات کامل تصمیم\r\n        \"\"\"\r\n        \r\n        explanation = {\r\n            \"query\": query,\r\n            \"selected_method\": selected_method,\r\n            \"reasoning\": score.reasoning,\r\n            \"features\": {\r\n                \"complexity\": features.complexity.value,\r\n                \"urgency\": features.urgency.value,\r\n                \"domain\": features.domain,\r\n                \"requires_knowledge\": features.requires_knowledge,\r\n                \"requires_calculation\": features.requires_calculation,\r\n                \"is_specialized\": features.is_specialized,\r\n                \"confidence_needed\": f\"{features.confidence_needed:.0%}\"\r\n            },\r\n            \"scores\": {\r\n                \"final\": f\"{score.score:.1f}\",\r\n                \"speed\": f\"{score.speed_score:.1f}\",\r\n                \"accuracy\": f\"{score.accuracy_score:.1f}\",\r\n                \"cost\": f\"{score.cost_score:.1f}\"\r\n            }\r\n        }\r\n        \r\n        if all_scores:\r\n            explanation[\"alternatives\"] = [\r\n                {\r\n                    \"method\": s.method,\r\n                    \"score\": f\"{s.score:.1f}\",\r\n                    \"reasoning\": s.reasoning\r\n                }\r\n                for s in all_scores[:3]  # تاپ 3\r\n            ]\r\n        \r\n        return explanation\r\n    \r\n    def update_performance(self, method: str, success: bool, execution_time: float):\r\n        \"\"\"به‌روزرسانی آمار عملکرد برای یادگیری\"\"\"\r\n        \r\n        if method not in self.method_performance:\r\n            return\r\n        \r\n        perf = self.method_performance[method]\r\n        \r\n        # به‌روزرسانی نرخ موفقیت (با میانگین متحرک)\r\n        alpha = 0.1  # ضریب یادگیری\r\n        perf[\"success_rate\"] = (\r\n            (1 - alpha) * perf[\"success_rate\"] +\r\n            alpha * (1.0 if success else 0.0)\r\n        )\r\n        \r\n        # به‌روزرسانی زمان متوسط\r\n        perf[\"avg_time\"] = (\r\n            (1 - alpha) * perf[\"avg_time\"] +\r\n            alpha * execution_time\r\n        )\r\n    \r\n    def get_performance_stats(self) -> Dict:\r\n        \"\"\"دریافت آمار عملکرد همه روش‌ها\"\"\"\r\n        return {\r\n            method: {\r\n                \"success_rate\": f\"{stats['success_rate']:.1%}\",\r\n                \"avg_time\": f\"{stats['avg_time']:.2f}s\"\r\n            }\r\n            for method, stats in self.method_performance.items()\r\n        }\r\n",
    "format": "py"
  }
]